<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
  <!ENTITY ntxs "&#183;"> <!-- non terminal xref start -->
  <!ENTITY ntxe "&#183;"> <!-- non terminal xref end -->
  <!ENTITY lcmxs "&#9900;"> <!-- logical content model (property xref) start -->
  <!ENTITY lcmxe "&#9900;"> <!-- logical content model (property xref) end -->
]>
<book>
    <bookinfo>
        <title>DDOM Manual</title>
        <releaseinfo>&version;</releaseinfo>
        <legalnotice>
            <para>
                Copyright 2009 Andreas Veithen
            </para>
            <para>
                Licensed under the Apache License, Version 2.0 (the "License");
                you may not use this file except in compliance with the License.
                You may obtain a copy of the License at
            </para>
            <para>
                <ulink url="http://www.apache.org/licenses/LICENSE-2.0"/>
            </para>
            <para>
                Unless required by applicable law or agreed to in writing, software
                distributed under the License is distributed on an "AS IS" BASIS,
                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                See the License for the specific language governing permissions and
                limitations under the License.
            </para>
        </legalnotice>
    </bookinfo>
    
    <toc/>

    <part>
        <title>Architecture</title>
        <chapter>
            <title>Design goals</title>
            <para>
                High priority design goals:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The amount of new APIs created by the project should be as low as possible. In most of the
                        areas covered by this project, well defined, widely used and/or convenient APIs already
                        exist:
                    </para>
                    <table>
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>Area</entry><entry>Existing APIs/frameworks</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>XML object models</entry>
                                    <entry>DOM, Axiom, JDOM, DOM4J, XOM</entry>
                                </row>
                                <row>
                                    <entry>SOAP object models</entry>
                                    <entry>SAAJ, Axiom, Spring WS</entry>
                                </row>
                                <row>
                                    <entry>XML data sources</entry>
                                    <entry>JAXP (<classname>SAXSource</classname>, <classname>DOMSource</classname>,
                                           <classname>StreamSource</classname>), SAX (<classname>InputSource</classname>)</entry>
                                </row>
                                <row>
                                    <entry>XML data stream</entry>
                                    <entry>StAX (pull), SAX (push)</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                    <para>
                        The project should leverage existing APIs as much as possible and only introduce new APIs where
                        this is strictly necessary.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Medium priority design goals:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Many existing frameworks, in particular XML object models, are plagued by an issue related to
                        the <literal>xsd:QName</literal> type as defined by section 3.2.18 of
                        <biblioref linkend="bib.xmlschema.part2"/>.
                    </para>
                </listitem>
            </itemizedlist>
        </chapter>
        <chapter id="lcm">
            <title>The Logical Content Model</title>
            <section>
                <title>Introduction</title>
                <para>
                    The <firstterm>Logical Content Model</firstterm> defines an abstract data set describing
                    the information contained in a well-formed XML document. The purpose is to provide a consistent
                    set of definitions used throughout the rest of the documentation. It is important to understand
                    that the Logical Content Model is not the same as the <firstterm>Object Model</firstterm> that
                    describes the data structures that are used to physically represent the content of an XML
                    document as Java objects. While similar in spirit, the Logical Content Model is also different
                    from the XML Information Set defined in <biblioref linkend="bib.infoset"/>. The Logical
                    Content Model can be best thought of as a model of the output of a typical XML parser, as well
                    as a model for the input of a typical XML serializer. The
                    following items give an overview of the relationship of the Logical Content Model to
                    the Object Model, XML Infoset and the output of an XML parser:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Since DDOM uses deferred parsing, the Object Model not only represents the the content
                            of the XML document, but must keep track of the state of the underlying parser.
                            On the other hand, the Logical Content Model is not concerned with deferred parsing and
                            describes a view of the entire document.
                        </para>
                        <para>
                            document fragments
                        </para>
                        <para>
                            non coalesced text nodes
                        </para>
                        <para>
                            namespace aware and unaware elements and attributes
                        </para>
                        <para>
                            CDATA sections -> not in the infoset
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            In the Logical Content Model, attribute values and element content (i.e. text nodes)
                            are described in term of lexical space. On the other hand, the Object Model may
                            store this content by referring to the value space of the corresponding type.
                            E.g. if the document is linked to an XML schema, then the Object Model may
                            use a <classname>java.xml.namespace.QName</classname> object to store the content
                            of an element or attribute declared with the <type>xs:QName</type> schema type.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            XML Infoset is not suitable to describe the output of a namespace unaware
                            parser. In order to support Object Models which allow manipulation of
                            XML in a namespace unaware way, the Logical Content Model defines specific
                            information items for output of namespace unaware parsers.
                        </para>
                    </listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Information items</title>
                <section id="lcm.document">
                    <title>The document information item</title>
                    
                    <variablelist>
                        <varlistentry>
                            <term>children</term>
                            <listitem>
                                <para>
                                    An ordered list of child information items, in document order.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </section>
                <section>
                    <title>The document type declaration information item</title>
                    
                </section>
                <section id="lcm.element">
                    <title>Element information items</title>

                    <variablelist>
                        <varlistentry>
                            <term>children</term>
                            <listitem>
                                <para>
                                    An ordered list of child information items, in document order.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <section>
                        <title>Namepace aware element information items</title>
                        
                    </section>
                    <section>
                        <title>Namespace unaware element information item</title>
                        <para>
                            A namespace unaware element information item is produced by a namespace unaware parser
                            for each <xref linkend="NT-element"/>
                            appearing in the document. It has the following properties:
                        </para>
                        <variablelist>
                            <varlistentry>
                                <term>name</term>
                                <listitem>
                                    <para>
                                        The <xref linkend="NT-Name"/> of the element.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                        <para>
                            When a namespace unaware element information item is serialized, it is written as-is, without
                            consideration for the namespace declarations that are in scope at the location
                            where the element is written.
                        </para>
                        <note>
                            <para>
                                This has important consequences if the resulting document is later
                                parsed by a namespace aware parser. The behavior depends on the
                                structure of its name:
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        If the name is an <xref linkend="NT-NCName"/>,
                                        the element will pick up the default namespace in scope. Since a default namespace
                                        always exists, the element is always namespace well-formed.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        If the name is a <xref linkend="NT-PrefixedName"/>,
                                        then it will pick up the namespace bound to the corresponding prefix.
                                        If no corresponding namespace declaration is in scope, the element
                                        is not namespace well-formed.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        Otherwise the element is never namespace well-formed.
                                    </para>
                                </listitem>
                            </itemizedlist>
                            <para>
                                This implies that a namespace unaware element information item may never
                                be considered to have a well-defined namespace.
                            </para>
                        </note>
                    </section>
                </section>
                <section id="lcm.attribute">
                    <title>Attribute information items</title>
                    
                    <variablelist>
                        <varlistentry>
                            <term>children</term>
                            <listitem>
                                <para>
                                    An ordered list of child information items, in document order.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <section>
                        <title>Namespace aware attribute information items</title>
                        
                    </section>
                    <section>
                        <title>Namespace unaware attribute information items</title>
                        <para>
                            A namespace unaware attribute information item is produced by a namespace unaware parser
                            for each <xref linkend="NT-Attribute"/>
                            appearing in the document. It has the following properties:
                        </para>
                        <variablelist>
                            <varlistentry>
                                <term>name</term>
                                <listitem>
                                    <para>
                                        The <xref linkend="NT-Name"/> of the attribute.
                                    </para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                        <para>
                            When a namespace unaware attribute information item is serialized, it is written as-is, without
                            consideration for the namespace declarations that are in scope at the location
                            where the element is written.
                        </para>
                        <note>
                            <para>
                                The consequences of this are slightly different than for namespace unaware elements:
                            </para>
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        If the name is an <xref linkend="NT-NCName"/>,
                                        the attribute will be namespace well-formed and have no namespace.
                                    </para>
                                </listitem>
                                <listitem>
                                    <para>
                                        If the name is not an <xref linkend="NT-NCName"/>, then the attribute will be
                                        either not namespace well-formed or it will pick up the namespace of one
                                        of the namespace declarations in scope, exactly as for namespace unaware
                                        elements.
                                    </para>
                                </listitem>
                            </itemizedlist>
                            <para>
                                The important point to note here is that in contrast to namespace unaware elements,
                                a namespace unaware attribute has a well-defined namespace if its name is a
                                <xref linkend="NT-NCName"/>. This is also true if the name is a
                                <xref linkend="NT-PrefixedName"/>
                                with <literal>xml</literal> as prefix, because this prefix is always implicitly
                                bound to <literal>http://www.w3.org/XML/1998/namespace</literal> (and
                                must not be bound to any other namespace).
                                There is thus a partial equivalence between namespace unaware and
                                namespace aware attribute information items.
                            </para>
                        </note>
                    </section>
                </section>
                <section id="lcm.text">
                    <title>Text information items</title>
                    <para>
                        The <xref linkend="NT-document"/> production may be rewritten as follows:
                    </para>
                    <productionset>
                        <production id="NT-document-alt">
                            <lhs>document</lhs>
                            <rhs>
                                <nonterminal def="#NT-XMLDecl">XMLDecl</nonterminal>?
                                (<nonterminal def="#NT-Comment">Comment</nonterminal>
                                | <nonterminal def="#NT-PI">PI</nonterminal>
                                | <nonterminal def="#NT-DocText">DocText</nonterminal>)*
                                (<nonterminal def="#NT-doctypedecl">doctypedecl</nonterminal>
                                 (<nonterminal def="#NT-Comment">Comment</nonterminal>
                                 | <nonterminal def="#NT-PI">PI</nonterminal>
                                 | <nonterminal def="#NT-DocText">DocText</nonterminal>)*)?
                                <nonterminal def="#NT-element">element</nonterminal>
                                (<nonterminal def="#NT-Comment">Comment</nonterminal>
                                | <nonterminal def="#NT-PI">PI</nonterminal>
                                | <nonterminal def="#NT-DocText">DocText</nonterminal>)*
                            </rhs>
                        </production>
                        <production id="NT-DocText" xreflabel="&ntxs;DocText&ntxe;">
                            <lhs>DocText</lhs>
                            <rhs><nonterminal def="#NT-S">S</nonterminal></rhs>
                        </production>
                    </productionset>
                    <para>
                        The <xref linkend="NT-content"/> production appearing in <xref linkend="NT-element"/>
                        may be rewritten as follows:
                    </para>
                    <productionset>
                        <production id="NT-content-alt">
                            <lhs>content</lhs>
                            <rhs>
                                <nonterminal def="#NT-ElemText">ElemText</nonterminal>?
                                ((<nonterminal def="#NT-element">element</nonterminal>
                                | <nonterminal def="#NT-DeclaredEntityRef">DeclaredEntityRef</nonterminal>
                                | <nonterminal def="#NT-CDSect">CDSect</nonterminal>
                                | <nonterminal def="#NT-PI">PI</nonterminal>
                                | <nonterminal def="#NT-Comment">Comment</nonterminal>)
                                <nonterminal def="#NT-ElemText">ElemText</nonterminal>?)*
                            </rhs>
                        </production>
                        <production id="NT-ElemText" xreflabel="&ntxs;ElemText&ntxe;">
                            <lhs>ElemText</lhs>
                            <rhs>
                                <nonterminal def="#NT-CharData">CharData</nonterminal>?
                                ((<nonterminal def="#NT-CharRef">CharRef</nonterminal> | <nonterminal def="#NT-PredefinedEntityRef">PredefinedEntityRef</nonterminal>)
                                 <nonterminal def="#NT-CharData">CharData</nonterminal>?)*
                            </rhs>
                        </production>
                        <production id="NT-PredefinedEntityRef" xreflabel="&ntxs;PredefinedEntityRef&ntxe;"> <!-- Concept defined in XML 1.0, 4.6 Predefined Entities -->
                            <lhs>PredefinedEntityRef</lhs>
                            <rhs>'&amp;amp;' | '&amp;lt;' | '&amp;gt;' | '&amp;apos;' | '&amp;quot;'</rhs>
                        </production>
                        <production id="NT-DeclaredEntityRef">
                            <lhs>DeclaredEntityRef</lhs>
                            <rhs><nonterminal def="#NT-EntityRef">EntityRef</nonterminal> - <nonterminal def="#NT-PredefinedEntityRef">PredefinedEntityRef</nonterminal></rhs>
                        </production>
                    </productionset>
                    <para>
                        In the same way, the <xref linkend="NT-AttValue"/> production can be transformed:
                    </para>
                    <productionset>
                        <production id="NT-AttValue-alt">
                            <lhs>AttValue</lhs>
                            <rhs>'"' <nonterminal def="#NT-AttValueContent1">AttValueContent1</nonterminal> '"' 
                                | "'" <nonterminal def="#NT-AttValueContent2">AttValueContent2</nonterminal> "'"
                            </rhs>
                        </production>
                        <production id="NT-AttValueContent1">
                            <lhs>AttValueContent1</lhs>
                            <rhs>
                                <nonterminal def="#NT-AttText1">AttText1</nonterminal>?
                                (<nonterminal def="#NT-DeclaredEntityRef">DeclaredEntityRef</nonterminal>
                                <nonterminal def="#NT-AttText1">AttText1</nonterminal>?)*
                            </rhs>
                        </production>
                        <production id="NT-AttValueContent2">
                            <lhs>AttValueContent2</lhs>
                            <rhs>
                                <nonterminal def="#NT-AttText2">AttText2</nonterminal>?
                                (<nonterminal def="#NT-DeclaredEntityRef">DeclaredEntityRef</nonterminal>
                                <nonterminal def="#NT-AttText2">AttText2</nonterminal>?)*
                            </rhs>
                        </production>
                        <production id="NT-AttText1" xreflabel="&ntxs;AttText1&ntxe;">
                            <lhs>AttText1</lhs>
                            <rhs>
                                ([^&lt;&amp;"]
                                | <nonterminal def="#NT-CharRef">CharRef</nonterminal>
                                | <nonterminal def="#NT-PredefinedEntityRef">PredefinedEntityRef</nonterminal>)*
                            </rhs>
                        </production>
                        <production id="NT-AttText2" xreflabel="&ntxs;AttText2&ntxe;">
                            <lhs>AttText2</lhs>
                            <rhs>
                                ([^&lt;&amp;']
                                | <nonterminal def="#NT-CharRef">CharRef</nonterminal>
                                | <nonterminal def="#NT-PredefinedEntityRef">PredefinedEntityRef</nonterminal>)*
                            </rhs>
                        </production>
                    </productionset>
                    <para>
                        For CDATA sections:
                    </para>
                    <productionset>
                        <production id="NT-CDSect-alt" xreflabel="&ntxs;CDSect&ntxe;">
                            <lhs>CDSect</lhs>
                            <rhs>
                                '&lt;![CDATA[' <nonterminal def="#NT-CData">CData</nonterminal> ']]&gt;'
                            </rhs>
                        </production>
                        <production>
                            <lhs>CData</lhs>
                            <rhs>(<nonterminal def="#NT-Char">Char</nonterminal>* - (<nonterminal def="#NT-Char">Char</nonterminal>* ']]&gt;' <nonterminal def="#NT-Char">Char</nonterminal>*))</rhs> 
                        </production>
                    </productionset>
                    <para>
                        For comments:
                    </para>
                    <productionset>
                        <production id="NT-Comment-alt">
                            <lhs>Comment</lhs>
                            <rhs>
                                '&lt;!--' <nonterminal def="#NT-CommentText">CommentText</nonterminal> '-->'
                            </rhs>
                        </production>
                        <production id="NT-CommentText" xreflabel="&ntxs;CommentText&ntxe;">
                            <lhs>CommentText</lhs>
                            <rhs>
                                ((<nonterminal def="#NT-Char">Char</nonterminal> - '-') | ('-' (<nonterminal def="#NT-Char">Char</nonterminal> - '-')))*
                            </rhs>
                        </production>
                    </productionset>
                    <para>
                        For processing instructions:
                    </para>
                    <productionset>
                        <production id="NT-PI-alt">
                            <lhs>PI</lhs>
                            <rhs>
                                '&lt;?' <nonterminal def="#NT-PITarget">PITarget</nonterminal>
                                (<nonterminal def="#NT-S">S</nonterminal> <nonterminal def="#NT-PIText">PIText</nonterminal>)? '?>'
                            </rhs>
                        </production>
                        <production id="NT-PIText" xreflabel="&ntxs;PIText&ntxe;">
                            <lhs>PIText</lhs>
                            <rhs>
                                <nonterminal def="#NT-Char">Char</nonterminal>* - (<nonterminal def="#NT-Char">Char</nonterminal>* '?>' <nonterminal def="#NT-Char">Char</nonterminal>*)
                            </rhs>
                        </production>
                    </productionset>
                    <para>
                        For every <xref linkend="NT-DocText"/>, <xref linkend="NT-ElemText"/>, <xref linkend="NT-AttText1"/>, <xref linkend="NT-AttText2"/>,
                        <xref linkend="NT-CData"/><footnote><para>Note that <xref linkend="NT-CData"/> only appears
                        as part of <xref linkend="NT-CDSect"/>; thus the definition is consistent.</para></footnote>,
                        <xref linkend="NT-CommentText"/> and <xref linkend="NT-PIText"/> the
                        parser produces one or more text information items. They may thus appear as children of
                        <link linkend="lcm.document">document</link>, <link linkend="lcm.element">element</link>,
                        <link linkend="lcm.attribute">attribute</link>, <link linkend="lcm.cdata">CDATA section</link>,
                        <link linkend="lcm.comment">comment</link> and <link linkend="lcm.pi">processing instruction</link> information
                        items. The individual text information
                        items produced for a single <xref linkend="NT-DocText"/>, <xref linkend="NT-ElemText"/>,
                        <xref linkend="NT-AttText1"/>, <xref linkend="NT-AttText2"/>, <xref linkend="NT-CData"/>, <xref linkend="NT-CommentText"/>
                        or <xref linkend="NT-PIText"/> are called <firstterm>segments</firstterm>.
                        The concatenation of the content of these segments must equal the value of the token
                        after substitution of all <xref linkend="NT-CharRef"/> and <xref linkend="NT-PredefinedEntityRef"/> tokens
                        by their corresponding characters.
                        The way how tokens are split into segments is arbitrary and segment boundaries have
                        no syntactic meaning.
                    </para>
                    <para>
                        TODO: Evaluate what this means for section 3.3.3 "Attribute-Value Normalization" in the XML specs.
                    </para>
                </section>
                <section>
                    <title>Entity reference information items</title>
                    <para>
                        Unless the parser is configured to replace entity reference, an entity reference information item is
                        produced by the parser for every <xref linkend="NT-EntityRef"/>
                        which doesn't refer to one of the predefined entities <literal>amp</literal>, <literal>lt</literal>,
                        <literal>gt</literal>, <literal>apos</literal> or <literal>quot</literal>.
                        The entity reference information item has the following properties:
                    </para>
                    <variablelist>
                        <varlistentry id="prop-lcm.entityref.name" xreflabel="&lcmxs;name&lcmxe;">
                            <term>name</term>
                            <listitem>
                                <para>
                                    The name of the entity [or a reference to an entity information item???]
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry id="prop-lcm.entityref.children" xreflabel="&lcmxs;children&lcmxe;">
                            <term>children</term>
                            <listitem>
                                <para>
                                    An ordered list of child information items that describe the content of the
                                    entity reference after expansion.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <note>
                        <para>
                            It is important to note that the <xref linkend="prop-lcm.entityref.children"/>
                            of two entity reference information items having the same
                            <xref linkend="prop-lcm.entityref.name"/> are not necessarily the same.
                            The reason for this is that the <xref linkend="prop-lcm.nsaware.namespaceURI"/>
                            of namespace aware elements and attributes generated during the entity
                            expansion may depend on the namespace context in which the entity reference
                            appears.
                        </para>
                    </note>
                    <para>
                        An entity reference information item is serialized as an <xref linkend="NT-EntityRef"/>
                        or, if the serializer is requested to do so, by replacing the entity reference by the content of the entity.
                    </para>
                </section>
                <section id="lcm.cdata">
                    <title>CDATA section information items</title>
                    <para>
                        A parser produces a CDATA section information item for every <xref linkend="NT-CDSect"/>.
                        It has the following properties: 
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>children</term>
                            <listitem>
                                <para>
                                    An ordered list of child information items, in document order. This list
                                    may only contain <link linkend="lcm.text">text information items</link>.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        When a CDATA section information item is serialized, a single <xref linkend="NT-CDSect"/> is
                        produced by concatenating the segments. It is the responsibility of the serializer to
                        enfore that the <xref linkend="NT-CData"/> does not contain the <literal>']]&gt;'</literal>
                        character sequence.
                    </para>
                </section>
                <section id="lcm.comment">
                    <title>Comment information items</title>
                    <para>
                        A parser produces a comment information item for every <xref linkend="NT-Comment"/>.
                        It has the following properties:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>children</term>
                            <listitem>
                                <para>
                                    An ordered list of child information items, in document order. This list
                                    may only contain <link linkend="lcm.text">text information items</link>.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </section>
                <section id="lcm.pi">
                    <title>Processing instruction information items</title>
                    <para>
                        A parser produces a processing instruction information item for every
                        <xref linkend="NT-PI"/>. It has the following properties:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>target</term>
                            <listitem>
                                <para>
                                    The <xref linkend="NT-PITarget"/>.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>children</term>
                            <listitem>
                                <para>
                                    An ordered list of child information items, in document order. This list
                                    may only contain <link linkend="lcm.text">text information items</link>.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </section>
                <section>
                    <title>Unparsed entity information items</title>
                    
                </section>
                <section>
                    <title>Notation information items</title>
                    
                </section>
                <section>
                    <title>Namespace declaration information items</title>
                
                </section>
            </section>
            <section>
                <title>Information item classification</title>
                <para>
                    In <xref linkend="lcm.element"/> and <xref linkend="lcm.attribute"/>, we already
                    established two abstract classes of information items, namely element information
                    items and attribute information items. This section identifies several further
                    classifications that will prove to be useful.
                </para>
                <section>
                    <title>Parent, child and leaf information items</title>
                    <para>
                        Parent information items are information items that have a parent property.
                        Child information items are information items that have a children property.
                        Leaf information items are child information items that are not parent information
                        items.
                    </para>
                    <table id="tbl.lcm.parent-child-leaf">
                        <caption>Parent, child and leaf information items</caption>
                        <tgroup cols="4">
                            <thead>
                                <row>
                                    <entry>Information item</entry><entry>Parent</entry><entry>Child</entry><entry>Leaf</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>Document</entry><entry>X</entry><entry></entry><entry></entry>
                                </row>
                                <row>
                                    <entry>Document type declaration</entry><entry></entry><entry>X</entry><entry>X</entry>
                                </row>
                                <row>
                                    <entry>Element</entry><entry>X</entry><entry>X</entry><entry></entry>
                                </row>
                                <row>
                                    <entry>Attribute</entry><entry>X</entry><entry></entry><entry></entry>
                                </row>
                                <row>
                                    <entry>Text</entry><entry></entry><entry>X</entry><entry>X</entry>
                                </row>
                                <row>
                                    <entry>CDATA section</entry><entry>X</entry><entry>X</entry><entry></entry>
                                </row>
                                <row>
                                    <entry>Comment</entry><entry>X</entry><entry>X</entry><entry></entry>
                                </row>
                                <row>
                                    <entry>Processing instruction</entry><entry>X</entry><entry>X</entry><entry></entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                </section>
                <section>
                    <title>Namespace aware named information items</title>
                    
                    <para>
                        Common properties:
                    </para>
                    <variablelist>
                        <varlistentry id="prop-lcm.nsaware.namespaceURI" xreflabel="&lcmxs;namespaceURI&lcmxe;">
                            <term>namespaceURI</term>
                            <listitem>
                                <para>
                                    The namespace URI of the named information item.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </section>
                <section>
                    <title>Namespace unaware named information items</title>
                    
                </section>
                <section>
                    <title>Character data information items</title>
                    
                </section>
                <section>
                    <title>Summary</title>
                    <para>
                        UML diagram here
                    </para>
                </section>
            </section>
            <section>
                <title>Syntactic structures not captured by the Logical Content Model</title>
                
            </section>
            <section>
                <title>Transformations of the Logical Content Model</title>
                <section>
                    <title>Coalescing</title>
                    
                </section>
                <section>
                    <title>Entity reference expansion</title>
                    
                </section>
                <section>
                    <title>"Namespace repairing"</title>
                    
                </section>
            </section>
            <section>
                <title>Comparison with existing object models</title>
                <section>
                    <title>DOM</title>
                    
                    <itemizedlist>
                        <listitem>
                            <para>
                                DOM doesn't support CDATA segmentation.
                            </para>
                        </listitem>
                    </itemizedlist>
                    
                </section>
                <section>
                    <title>Axiom</title>
                    
                </section>
            </section>
        </chapter>
        <chapter>
            <title>The Logical Event Model</title>
            <section>
                <title>Definition</title>
                <para>
                    TODO: Define the LEM by deriving it from the LCM
                </para>
            </section>
            <section>
                <title>Comparison with existing parsers and serializers</title>
                <section>
                    <title>SAX</title>
                    
                </section>
                <section>
                    <title>StAX</title>
                    <section>
                        <title>The <classname>XMLStreamReader</classname> interface</title>
                        
                    </section>
                    <section>
                        <title>The <classname>XMLStreamWriter</classname> interface</title>
                        
                    </section>
                </section>
                <section>
                    <title>Xerces XNI</title>
                    
                </section>
            </section>
        </chapter>
        <chapter>
            <title>The Core Model</title>
            <para>
                The Core Model is a mapping of the Logical Content Model defined in <xref linkend="lcm"/>
                into a set of interfaces in the Java language. The Core Model is thus an abstract API.
                The mapping between the two models is mostly direct, but there are some slight
                differences that will be explained in the following sections.
            </para>
            <section>
                <title>Document fragments</title>
                <para>
                    While the Logical Content Model is a model of the content of a well-formed
                    XML document, the Core Model is an API that allows user code to manipulate,
                    edit and create XML documents. To allow these manipulations, it is necessary
                    to introduce a node type that has no corresponding information item.
                    ...
                </para>
            </section>
            <section>
                <title>Compact parent nodes</title>
                <para>
                    The Logical Content Model defines the children property as an ordered list
                    of child information items. The direct transcription of this would be to
                    specify that a parent node is a node that has an ordered list of child nodes.
                    There are several reasons why this is too simplistic:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            <xref linkend="tbl.lcm.parent-child-leaf"/> shows that most nodes are
                            actually parent nodes. In practice however, many instances of parent
                            nodes will only contain a single text node as their child. This is
                            certainly true for attributes, CDATA sections, comments and
                            processing instructions. Surprisingly, this is also true for elements,
                            especially in SOAP messages. Indeed, in a typical Web service message,
                            most elements are instances of simple schema types, and thus
                            contain a single text information item (unless the element is empty or
                            the parser decides to segment the value of the element).
                        </para>
                        <para>
                            Storing this character data in separate node instances creates an
                            overhead that in most cases is unnecessary because the text node will
                            never be accessed directly. Instead, the application typically uses
                            a method on the parent node to retrieve its text content.
                            E.g. for elements, the following methods can be used, depending on
                            the API:
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>
                                    DOM: <methodname>Node#getTextContent()</methodname> invoked on
                                    the <classname>Element</classname> instance.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    Axiom: <methodname>OMElement#getText()</methodname>.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    StAX: <methodname>XMLStreamReader#getElementText()</methodname>.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <para>
                            In the case of attributes, CDATA sections, comments and processing
                            instructions, some APIs even don't have methods to
                            access the child nodes because they don't consider these nodes as
                            parent nodes. Especially for attributes, the overhead created
                            by storing their values in separate child nodes would be
                            annoying.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The Logical Content Model only captures the content of a document,
                            but not its semantics. In particular, if the document is described
                            by an XML schema, then for simple types, the Logical Content Model
                            only refers to the lexical space but never to the value
                            space of these types.
                            To support frontends such as Axiom [and SDO??], it is necessary 
                            to allow the Core Model to store content using objects other than
                            strings.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            One of the design goals is to support sourced content.
                            [TODO: (link to) definition here]
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Therefore, the design of the Core Model specifies that the content of a parent
                    node may be stored in one of the following forms:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            As an order list of child nodes.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            As a <firstterm>value object</firstterm>, i.e. a single String object or
                            an object of another type that has a well-defined mapping from value to lexical space. Examples are
                            <classname>javax.xml.namespace.QName</classname> for <type>xs:QName</type>
                            and <classname>javax.activation.DataHandler</classname> for <type>xs:base64Binary</type>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            An object of type <classname>FragmentSource</classname>.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    An instance that stores its content as an order list of child nodes is said to
                    be <firstterm>expanded</firstterm>. If it uses one of the other two representations,
                    it is said to be <firstterm>unexpanded</firstterm>. When the children of an
                    unexpanded parent node are queried, the node will be <firstterm>expanded</firstterm>,
                    i.e. the alternative representation will be replaced by an equivalent list of
                    child nodes. Node types supporting this mechanism are called
                    <firstterm>compact</firstterm>. Note that in the Core Model, all parent nodes
                    are compact [Well, not yet...].
                </para>
                <para>
                    If the content is stored using a <classname>FragmentSource</classname>, then
                    deferred parsing is used when the node is expanded. This means that after
                    expansion, the list of child nodes may be incomplete and only contain the
                    materialized child nodes. Of course this is transparent to the code
                    interacting with the Core Model.
                </para>
                <para>
                    In this context it is important not to confuse the concept
                    of "expanded" with the concept of "complete".
                    [TODO: elaborate a bit more; it is clear that an incomplete node may be expanded;
                    but may a complete node become incomplete when it is expanded?!?] 
                </para>
                <para>
                    TODO: specify what happens to value objects after expansion!
                </para>
            </section>
            <section>
                <title>Read-only nodes</title>
                <para>
                    For consistency during serialization, modifying the descendants of an entity
                    reference node is disallowed. Since this is the only case of read-only nodes,
                    it is specified that a node is read-only if and only if it is an entity
                    reference node or a descendant of an entity reference node. It is the
                    responsibility of the backend to enforce this.
                </para>
                <para>
                    One can see that there are three different ways to implement this behavior:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Let the each node have an attribute that indicates
                            if it is read-only and set this attribute appropriately.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Explicitly check if the node has an ancestor which is an entity
                            reference.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Let parent nodes have an explicit flag and let leaf nodes (i.e. text nodes) check
                            if they are children of a read-only node.
                        </para>
                    </listitem>
                </itemizedlist>
            </section>
            <section>
                <title>UML diagram</title>
                
            </section>
                <section>
                    <title>Interface design</title>
                    <para>
                        The following principles and guidelines have been applied in the design of the
                        Core Model API:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                All interfaces representing nodes have names starting with <literal>Core</literal>.
                                More precisely, this convention applies to all interfaces that (after weaving)
                                may be implemented by a class that at the same time implements an interface
                                from the frontend API. While not strictly necessary, this convention makes it
                                easy to distinguish interfaces from the two APIs (e.g. <classname>CoreElement</classname>
                                and DOM's <classname>Element</classname> interface).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                All methods defined by the interfaces identified in the previous item have names
                                starting with <literal>core</literal>. This is necessary to avoid any possible conflict
                                with methods defined by frontend APIs.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Several methods operate on more than one node. E.g., inserting a node requires
                                references to two nodes, namely the node to insert and the node defining the
                                position in the document (typically the future parent or sibling). In these cases
                                there are several possible ways to define the method. Depending on the selected
                                definition, the node on which the method must be invoked and the parameters
                                passed to the call vary. E.g. a method that inserts a new sibling may either be
                                defined such that it is invoked on the existing node or such that it is invoked
                                on the node to be inserted.
                            </para>
                            <para>
                                The guideline is to define methods such that they will be invoked on node instances
                                already part of the tree (and that don't change position) and that the parameter
                                represents the node to insert into the tree. In any case, redundancies such as
                                in the definition of DOM's <methodname>insertBefore</methodname> method (which must
                                be invoked on the parent node of the two nodes) should be strictly avoided.
                            </para>
                            <para>
                                One of the rationale for this guideline is that before actually inserting the node into the
                                tree, the Core Model implementation must make sure that it is an instance from the same
                                model<footnote><para>Note that because of weaving, it is not sufficient for the node to belong
                                to the same backend implementation.</para></footnote>, is owned by the same document and is
                                detached. In most cases, the backend implementation will also have to cast the parameters
                                of the method to the actual implementation classes. This can be conveniently combined
                                with the same-model check. Taking these different aspects into account, one can easily
                                see that the guideline described here produces to the most natural implementation code.
                            </para>
                        </listitem>
                    </orderedlist>
                </section>
        </chapter>
        <appendix>
            <title>XML grammar</title>
            <para>
                This appendix reproduces parts of the productions defined in <biblioref linkend="bib.xml"/>
                and <biblioref linkend="bib.namespaces"/>
                that are referenced in this document.
            </para>
            <section>
                <title>XML 1.0</title>
                <productionset>
                    <title>Characters and names</title>
                    <production id="NT-Char">
                        <lhs>Char</lhs>
                        <rhs>#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]</rhs>
                    </production>
                    <production id="NT-NameStartChar">
                        <lhs>NameStartChar</lhs>
                        <rhs>":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</rhs>
                    </production>
                    <production id="NT-NameChar">
                        <lhs>NameChar</lhs>
                        <rhs><nonterminal def="#NT-NameStartChar">NameStartChar</nonterminal> | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]</rhs>
                    </production>
                    <production id="NT-Name" xreflabel="&ntxs;Name&ntxe;">
                        <lhs>Name</lhs>
                        <rhs><nonterminal def="#NT-NameStartChar">NameStartChar</nonterminal> (<nonterminal def="#NT-NameChar">NameChar</nonterminal>)*</rhs>
                    </production>
                </productionset>
                <productionset>
                    <title>Document</title>
                    <production id="NT-document" xreflabel="&ntxs;document&ntxe;">
                        <lhs>document</lhs>
                        <rhs>
                            <nonterminal def="#NT-prolog">prolog</nonterminal>
                            <nonterminal def="#NT-element">element</nonterminal>
                            <nonterminal def="#NT-Misc">Misc</nonterminal>*
                        </rhs>
                    </production>
                    <production id="NT-prolog">
                        <lhs>prolog</lhs>
                        <rhs>
                            <nonterminal def="#NT-XMLDecl">XMLDecl</nonterminal>?
                            <nonterminal def="#NT-Misc">Misc</nonterminal>*
                            (<nonterminal def="#NT-doctypedecl">doctypedecl</nonterminal>
                            <nonterminal def="#NT-Misc">Misc</nonterminal>*)?
                        </rhs>
                    </production>
                    <production id="NT-Misc">
                        <lhs>Misc</lhs>
                        <rhs>
                            <nonterminal def="#NT-Comment">Comment</nonterminal>
                          | <nonterminal def="#NT-PI">PI</nonterminal>
                          | <nonterminal def="#NT-S">S</nonterminal>
                        </rhs>
                    </production>
                </productionset>
                <productionset>
                    <title>Element</title>
                    <production id="NT-element" xreflabel="&ntxs;element&ntxe;">
                        <lhs>element</lhs>
                        <rhs>
                            <nonterminal def="#NT-EmptyElemTag">EmptyElemTag</nonterminal>
                          | <nonterminal def="#NT-STag">STag</nonterminal>
                            <nonterminal def="#NT-content">content</nonterminal>
                            <nonterminal def="#NT-ETag">ETag</nonterminal>
                        </rhs>
                    </production>
                    <production id="NT-EmptyElemTag">
                        <lhs>EmptyElemTag</lhs>
                        <rhs>'&lt;' <nonterminal def="#NT-Name">Name</nonterminal> (<nonterminal def="#NT-S">S</nonterminal>
                            <nonterminal def="#NT-Attribute">Attribute</nonterminal>)* <nonterminal def="#NT-S">S</nonterminal>? '/>'</rhs>
                    </production>
                    <production id="NT-STag">
                        <lhs>STag</lhs>
                        <rhs>'&lt;' <nonterminal def="#NT-Name">Name</nonterminal> (<nonterminal def="#NT-S">S</nonterminal>
                            <nonterminal def="#NT-Attribute">Attribute</nonterminal>)* <nonterminal def="#NT-S">S</nonterminal>? '>'</rhs>
                    </production>
                    <production id="NT-ETag">
                        <lhs>ETag</lhs>
                        <rhs>'&lt;/' <nonterminal def="#NT-Name">Name</nonterminal> <nonterminal def="#NT-S">S</nonterminal>? '>'</rhs>
                    </production>
                    <production id="NT-Attribute" xreflabel="&ntxs;Attribute&ntxe;">
                        <lhs>Attribute</lhs>
                        <rhs>
                            <nonterminal def="#NT-Name">Name</nonterminal>
                            <nonterminal def="#NT-Eq">Eq</nonterminal>
                            <nonterminal def="#NT-AttValue">AttValue</nonterminal>
                        </rhs>
                    </production>
                    <production id="NT-AttValue" xreflabel="&ntxs;AttValue&ntxe;">
                        <lhs>AttValue</lhs>
                        <rhs>
                            '"' ([^&lt;&amp;"] | <nonterminal def="#NT-Reference">Reference</nonterminal>)* '"' 
                            | "'" ([^&lt;&amp;'] | <nonterminal def="#NT-Reference">Reference</nonterminal>)* "'"
                        </rhs>
                    </production>
                    <production id="NT-content" xreflabel="&ntxs;content&ntxe;">
                        <lhs>content</lhs>
                        <rhs>
                            <nonterminal def="#NT-CharData">CharData</nonterminal>?
                            ((<nonterminal def="#NT-element">element</nonterminal>
                            | <nonterminal def="#NT-Reference">Reference</nonterminal>
                            | <nonterminal def="#NT-CDSect">CDSect</nonterminal>
                            | <nonterminal def="#NT-PI">PI</nonterminal>
                            | <nonterminal def="#NT-Comment">Comment</nonterminal>)
                            <nonterminal def="#NT-CharData">CharData</nonterminal>?)*
                        </rhs>
                    </production>
                    <production id="NT-CharData">
                        <lhs>CharData</lhs>
                        <rhs>[^&lt;&amp;]* - ([^&lt;&amp;]* ']]&gt;' [^&lt;&amp;]*)</rhs>
                    </production>
                </productionset>
                <productionset>
                    <title>Character and entity references</title>
                    <production id="NT-Reference">
                        <lhs>Reference</lhs>
                        <rhs>
                            <nonterminal def="#NT-EntityRef">EntityRef</nonterminal>
                          | <nonterminal def="#NT-CharRef">CharRef</nonterminal>
                        </rhs> 
                    </production>
                    <production id="NT-EntityRef" xreflabel="&ntxs;EntityRef&ntxe;">
                        <lhs>EntityRef</lhs>
                        <rhs>
                            '&amp;' <nonterminal def="#NT-Name">Name</nonterminal> ';'
                        </rhs>
                    </production> 
                    <production id="NT-CharRef" xreflabel="&ntxs;CharRef&ntxe;">
                        <lhs>CharRef</lhs>
                        <rhs>'&amp;#' [0-9]+ ';' | '&amp;#x' [0-9a-fA-F]+ ';'</rhs>
                    </production>
                </productionset>
                <productionset>
                    <title>CDATA sections</title>
                    <production id="NT-CDSect" xreflabel="&ntxs;CDSect&ntxe;">
                        <lhs>CDSect</lhs>
                        <rhs>
                            <nonterminal def="#NT-CDStart">CDStart</nonterminal>
                            <nonterminal def="#NT-CData">CData</nonterminal>
                            <nonterminal def="#NT-CDEnd">CDEnd</nonterminal>
                        </rhs>
                    </production>
                    <production id="NT-CDStart">
                        <lhs>CDStart</lhs>
                        <rhs>'&lt;![CDATA['</rhs>
                    </production>
                    <production id="NT-CData" xreflabel="&ntxs;CData&ntxe;">
                        <lhs>CData</lhs>
                        <rhs>(<nonterminal def="#NT-Char">Char</nonterminal>* - (<nonterminal def="#NT-Char">Char</nonterminal>* ']]&gt;' <nonterminal def="#NT-Char">Char</nonterminal>*))</rhs> 
                    </production>
                    <production id="NT-CDEnd">
                        <lhs>CDEnd</lhs>
                        <rhs>']]&gt;'</rhs>
                    </production>
                </productionset>
                <productionset>
                    <title>Comments</title>
                    <production id="NT-Comment" xreflabel="&ntxs;Comment&ntxe;">
                        <lhs>Comment</lhs>
                        <rhs>
                            '&lt;!--' ((<nonterminal def="#NT-Char">Char</nonterminal> - '-') | ('-' (<nonterminal def="#NT-Char">Char</nonterminal> - '-')))* '-->'
                        </rhs>
                    </production>
                </productionset>
                <productionset>
                    <title>Processing instructions</title>
                    <production id="NT-PI" xreflabel="&ntxs;PI&ntxe;">
                        <lhs>PI</lhs>
                        <rhs>
                            '&lt;?' <nonterminal def="#NT-PITarget">PITarget</nonterminal>
                            (<nonterminal def="#NT-S">S</nonterminal> (<nonterminal def="#NT-Char">Char</nonterminal>* - (<nonterminal def="#NT-Char">Char</nonterminal>* '?>' <nonterminal def="#NT-Char">Char</nonterminal>*)))? '?>'
                        </rhs>
                    </production>
                    <production id="NT-PITarget" xreflabel="&ntxs;PITarget&ntxe;">
                        <lhs>PITarget</lhs>
                        <rhs>
                            <nonterminal def="#NT-Name">Name</nonterminal> - (('X' | 'x') ('M' | 'm') ('L' | 'l'))
                        </rhs>
                    </production>
                </productionset>
            </section>
            <section>
                <title>Namespaces in XML 1.0</title>
                <productionset>
                    <title>Names</title>
                    <production id="NT-NCName" xreflabel="&ntxs;NCName&ntxe;">
                        <lhs>NCName</lhs> 
                        <rhs>
                            <nonterminal def="#NT-Name">Name</nonterminal>
                            - (<nonterminal def="#NT-Char">Char</nonterminal>* ':' <nonterminal def="#NT-Char">Char</nonterminal>*)
                        </rhs>
                    </production>
                    <production id="NT-QName">
                        <lhs>QName</lhs>
                        <rhs>
                            <nonterminal def="#NT-PrefixedName">PrefixedName</nonterminal>
                          | <nonterminal def="#NT-UnprefixedName">UnprefixedName</nonterminal>
                        </rhs>
                    </production>
                    <production id="NT-PrefixedName" xreflabel="&ntxs;PrefixedName&ntxe;">
                        <lhs>PrefixedName</lhs>
                        <rhs>
                            <nonterminal def="#NT-Prefix">Prefix</nonterminal> ':' <nonterminal def="#NT-LocalPart">LocalPart</nonterminal>
                        </rhs>
                    </production>
                    <production id="NT-UnprefixedName">
                        <lhs>UnprefixedName</lhs>
                        <rhs>
                            <nonterminal def="#NT-LocalPart">LocalPart</nonterminal>
                        </rhs>
                    </production>
                    <production id="NT-Prefix" xreflabel="&ntxs;Prefix&ntxe;">
                        <lhs>Prefix</lhs>
                        <rhs>
                            <nonterminal def="#NT-NCName">NCName</nonterminal>
                        </rhs>
                    </production>
                    <production id="NT-LocalPart">
                        <lhs>LocalPart</lhs>
                        <rhs>
                            <nonterminal def="#NT-NCName">NCName</nonterminal>
                        </rhs>
                    </production>
                </productionset>
            </section>
        </appendix>
    </part>
    <part>
        <title>Developer guide</title>
        <chapter>
            <title>Backend development</title>
            
            <section>
                <title>Addressing the multiple inheritance problem</title>
                
            </section>
            
            <section>
                <title>Backend implementations and deferred parsing</title>
                <para>
                    If loading existing documents is supported<footnote><para>This may not be the
                    case for proxy backends.</para></footnote>, it is the responsibility of the
                    backend to implement deferred parsing. The component managing the on-demand
                    parsing and creation of nodes is called <firstterm>builder</firstterm> (see
                    for example the <classname>Builder</classname> class in the linked list
                    backend). There are several reasons why the builder implementation is
                    considered backend specific:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The node object lifecycle is backend specific. Some backends may create
                            nodes eagerly, i.e. immediately after reception of an XML event from
                            the underlying parser. Other backends may store the data in another
                            data structure and defer creation of the corresponding nodes until they
                            are actually accessed.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The builder will typically create nodes directly, without going through
                            the node factory. One reason is that names, namespace URIs and prefixes
                            received from the underlying parser are already canonicalized.
                        </para>
                    </listitem>
                </itemizedlist>
                <note>
                    <para>
                        The fact that the builder is part of the backend implementation and not
                        a generic component is a major architectural difference with respect to
                        Axiom, where the <classname>StAXOMBuilder</classname> class is used by
                        all implementations.
                    </para>
                </note>
            </section>
            <section>
                <title>What operations should force a node to be built?</title>
                <para>
                    Three possible types of builders:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Whenever the parent of the node changes or siblings are inserted after the node.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Whenever siblings are inserted after the node. --> the builder needs to maintain
                            a node stack
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Never --> the builder needs to keep even more information: the siblings inserted
                            immediately after the node + siblings added at the end
                        </para>
                    </listitem>
                </itemizedlist>
            </section>
        </chapter>
        <chapter>
            <title>Background material</title>
            <section>
                <title>Namespace unaware XML processing</title>
                <para>
                    ...
                </para>
            </section>
            <section>
                <title>Covariant literals</title>
                <para>
                    ...
                </para>
            </section>
            <section>
                <title>The StAX specification</title>
                <para>
                    The StAX specification comprises two parts: a specification document titled <quote>Streaming API
                    For XML JSR-173 Specification</quote> and a Javadoc describing the API. Both can be downloaded from the
                    <ulink url="http://jcp.org/en/jsr/detail?id=173">JSR-173 page</ulink>. Since StAX is part of Java 6,
                    the Javadocs can also be viewed
                    <ulink url="http://java.sun.com/javase/6/docs/api/javax/xml/stream/package-summary.html">online</ulink>. 
                </para>
                <section>
                    <title>Semantics of the <methodname>setPrefix</methodname> method</title>
                    <para>
                        Probably one of the more obscure parts of the StAX specifications is the meaning of the
                        <methodname>setPrefix</methodname><footnote><para>For simplicity, we only discuss
                        <methodname>setPrefix</methodname> here. The same remarks also apply to
                        <methodname>setDefaultNamespace</methodname>.</para></footnote> method defined by <classname>XMLStreamWriter</classname>.
                        To understand how this method works, it is necessary to look at different parts of the specification:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The Javadoc of the <methodname>setPrefix</methodname> method.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The table shown in the Javadoc of the <classname>XMLStreamWriter</classname> class
                                in Java 6<footnote><para>This table is not included in the Javadoc in the original StAX
                                specification.</para></footnote>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Section 5.2.2, <quote>Binding Prefixes</quote> of the specification.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The example shown in section 5.3.2, <quote>XMLStreamWriter</quote> of the specification.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        In addition, it is important to note the following facts:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The terms <firstterm>defaulting prefixes</firstterm> used in section 5.2.2 of the
                                specification and <firstterm>namespace repairing</firstterm> used in the Javadocs
                                of <classname>XMLStreamWriter</classname> are synonyms.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The methods writing namespace qualified information items, i.e.
                                <methodname>writeStartElement</methodname>, <methodname>writeEmptyElement</methodname>
                                and <methodname>writeAttribute</methodname> all come in two variants: one that
                                takes a namespace URI and a prefix as arguments and one that only takes a
                                namespace URI, but no prefix.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        The purpose of the <methodname>setPrefix</methodname> method is simply to define the prefixes that
                        will be used by the variants of the <methodname>writeStartElement</methodname>,
                        <methodname>writeEmptyElement</methodname> and <methodname>writeAttribute</methodname> methods
                        that only take a namespace URI (and the local name). This becomes clear by looking at the
                        table in the <classname>XMLStreamWriter</classname> Javadoc. Note that a call to
                        <methodname>setPrefix</methodname> doesn't cause any output and it is still necessary
                        to use <methodname>writeNamespace</methodname> to actually write the necessary
                        namespace declarations. Otherwise the produced document will not be well formed with
                        respect to namespaces.
                    </para>
                    <para>
                        The Javadoc of the <methodname>setPrefix</methodname> method also clearly defines the scope
                        of the prefix bindings defined using that method: a prefix bound using
                        <methodname>setPrefix</methodname> remains valid till the invocation of
                        <methodname>writeEndElement</methodname> corresponding to the last invocation of
                        <methodname>writeStartElement</methodname>. While not explicitly mentioned in the
                        specifications, it is clear that a prefix binding may be masked by another binding
                        for the same prefix defined in a nested element.
                    </para>
                    <para>
                        An aspect that may cause confusion is the fact that in the example shown in section
                        5.3.2 of the specifications, the calls to <methodname>setPrefix</methodname> (and
                        <methodname>setDefaultNamespace</methodname>) all appear immediately before a
                        call to <methodname>writeStartElement</methodname> or <methodname>writeEmptyElement</methodname>.
                        This may lead people to incorrectly believe that a prefix binding defined using
                        <methodname>setPrefix</methodname> only applies to the next element
                        written<footnote><para>Another factor that contributes to the confusion is that in SAX,
                        prefix mappings are always generated before the corresponding <methodname>startElement</methodname>
                        event and that their scope ends with the corresponding <methodname>endElement</methodname>
                        event. This is so because the <classname>ContentHandler</classname> interface specifies that
                        <quote>all <methodname>startPrefixMapping</methodname> events will occur immediately before the
                        corresponding <methodname>startElement</methodname> event, and all <methodname>endPrefixMapping</methodname>
                        events will occur immediately after the corresponding <methodname>endElement</methodname>
                        event</quote>.</para></footnote>.
                        This interpretation is clearly in contradiction with the <methodname>setPrefix</methodname>
                        Javadoc, unless one assumes that <quote>the current START_ELEMENT / END_ELEMENT pair</quote>
                        means the element opened by a call to <methodname>writeStartElement</methodname> immediately following
                        the call to <methodname>setPrefix</methodname>. This however would be a very arbitrary interpretation
                        of the Javadoc<footnote><para>Early versions of XL XP-J were based on this interpretation of the
                        specifications, but this has been corrected. Versions conforming to the specifications support
                        a special property called <varname>javax.xml.stream.XMLStreamWriter.isSetPrefixBeforeStartElement</varname>,
                        which always returns <code>Boolean.FALSE</code>. This allows to easily distinguish the non
                        conforming versions from the newer versions. Note that in contrast to what the usage of the reserved
                        <literal>javax.xml.stream</literal> prefix suggests, this is a vendor specific property that
                        is not supported by other implementations.</para></footnote>.
                    </para>
                    <para>
                        The correctness of the comments in the previous paragraph can be checked using the following
                        code snippet:
                    </para>
<programlisting>XMLOutputFactory f = XMLOutputFactory.newInstance();
XMLStreamWriter writer = f.createXMLStreamWriter(System.out);
writer.writeStartElement("root");
writer.setPrefix("p", "urn:ns1");
writer.writeEmptyElement("urn:ns1", "element1");
writer.writeEmptyElement("urn:ns1", "element2");
writer.writeEndElement();
writer.flush();
writer.close();</programlisting>
                    <para>
                        This produces the following output<footnote><para>This has been tested with
                        Woodstox 3.2.9, SJSXP 1.0.1 and version 1.2.0 of the reference
                        implementation.</para></footnote>:
                    </para>
<screen><![CDATA[<root><p:element1/><p:element2/></root>]]></screen>
                    <para>
                        Since the code doesn't call <methodname>writeNamespace</methodname>, the output is obviously not
                        well formed with respect to namespaces, but it also clearly shows that the scope of the
                        prefix binding for <literal>p</literal> extends to the end of the
                        <sgmltag class="element">root</sgmltag> element and is not limited to
                        <sgmltag class="element">element1</sgmltag>.
                    </para>
                    <para>
                        To avoid unexpected results and keep the code maintainable, it is in general advisable to keep
                        the calls to <methodname>setPrefix</methodname> and <methodname>writeNamespace</methodname> aligned,
                        i.e. to make sure that the scope (in <classname>XMLStreamWriter</classname>) of the prefix binding
                        defined by <methodname>setPrefix</methodname> is compatible with the scope (in the produced
                        document) of the namespace declaration written by the corresponding call
                        to <methodname>writeNamespace</methodname>. This makes it necessary to write code like this:
                    </para>
<programlisting>writer.writeStartElement("p", "element1", "urn:ns1");
writer.setPrefix("p", "urn:ns1");
writer.writeNamespace("p", "urn:ns1");</programlisting>
                    <para>
                        As can be seen from this code snippet, keeping the two scopes in sync makes it necessary to use
                        the <methodname>writeStartElement</methodname> variant which takes an explicit prefix. Note that
                        this somewhat conflicts with the purpose of the <methodname>setPrefix</methodname> method;
                        one may consider this as a flaw in the design of the StAX API.
                    </para>
                </section>
                <section>
                    <title>The three <classname>XMLStreamWriter</classname> usage patterns</title>
                    <para>
                        Drawing the conclusions from the previous section and taking into account that
                        <classname>XMLStreamWriter</classname> also has a <quote>namespace repairing</quote>
                        mode, one can see that there are in fact three different ways to use
                        <classname>XMLStreamWriter</classname>. These usage patterns correspond to the
                        three bullets in section 5.2.2 of the StAX specification<footnote><para>The content
                        of this section is largely based on a <ulink url="http://markmail.org/message/olsdl3p3gciqqeob">reply
                        posted by Tatu Saloranta on the Axiom mailing list</ulink>. Tatu is the main developer of the
                        Woodstox project.</para></footnote>:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                In the <quote>namespace repairing</quote> mode (enabled by the
                                <varname>javax.xml.stream.isRepairingNamespaces</varname> property), the writer
                                takes care of all namespace bindings and declarations, with minimal help from
                                the calling code. This will always produce output that is well-formed with respect
                                to namespaces. On the other hand, this adds some overhead and the result may
                                depend on the particular StAX implementation (though the result produced by
                                different implementations will be equivalent).
                            </para>
                            <para>
                                In repairing mode the calling code should avoid writing namespaces explicitly
                                and leave that job to the writer. There is also no need to call
                                <methodname>setPrefix</methodname>, except to suggest a preferred prefix for
                                a namespace URI. All variants of <methodname>writeStartElement</methodname>,
                                <methodname>writeEmptyElement</methodname> and <methodname>writeAttribute</methodname>
                                may be used in this mode, but the implementation can choose whatever prefix mapping
                                it wants, as long as the output results in proper URI mapping for elements and
                                attributes.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Only use the variants of the writer methods that take an explicit prefix together
                                with the namespace URI. In this usage pattern, <methodname>setPrefix</methodname>
                                is not used at all and it is the responsibility of the calling code to keep
                                track of prefix bindings.
                            </para>
                            <para>
                                Note that this approach is difficult to implement when different parts of the output document
                                will be produced by different components (or even different libraries). Indeed, when
                                passing the <classname>XMLStreamWriter</classname> from one method or component
                                to the other, it will also be necessary to pass additional information about the
                                prefix mappings in scope at that moment, unless the it is acceptable to let the
                                called method write (potentially redundant) namespace declarations for all namespaces
                                it uses.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Use <methodname>setPrefix</methodname> to keep track of prefix bindings and make sure that
                                the bindings are in sync with the namespace declarations that have been written,
                                i.e. always use <methodname>setPrefix</methodname> immediately before or immediately
                                after each call to <methodname>writeNamespace</methodname>. Note that the code is
                                still free to use all variants of <methodname>writeStartElement</methodname>,
                                <methodname>writeEmptyElement</methodname> and <methodname>writeAttribute</methodname>;
                                it only needs to make sure that the usage it makes of these methods is consistent with
                                the prefix bindings in scope.
                            </para>
                            <para>
                                The advantage of this approach is that it allows to write modular code: when a
                                method receives an <classname>XMLStreamWriter</classname> object (to write
                                part of the document), it can use
                                the namespace context of that writer (i.e. <methodname>getPrefix</methodname>
                                and <methodname>getNamespaceContext</methodname>) to determine which namespace
                                declarations are currently in scope in the output document and to avoid
                                redundant or conflicting namespace declarations. Note that in order to do so,
                                such code will have to check for an existing prefix binding before starting
                                to use a namespace.
                            </para>
                        </listitem>
                    </orderedlist>
                </section>
            </section>
        </chapter>
    </part>
    
    <glossary>
        <glossentry>
            <glossterm>XML Object Model</glossterm>
            <glossdef>
                <para>
                    An Object Model defines a set of language independent or specific structures
                    (interfaces and classes) and a convention to map between these structures and
                    XML documents, where the set of supported XML documents may only be limited by
                    their well-formedness or validity (or by restrictions on less frequently used
                    XML or schema constructs).
                </para>
                <para>
                    Since it is assumed that the language structures are predefined, this
                    definition excludes databinding frameworks such as JAXB. On the other hand,
                    it includes SDO. Other examples are: DOM (language independent), JDOM,
                    DOM4J and Axiom (all Java specific).
                </para>
            </glossdef>
        </glossentry>
        <glossentry>
            <glossterm>Deferred parsing</glossterm>
            <glossdef>
                <para>
                    TODO
                </para>
            </glossdef>
        </glossentry>
        <glossentry>
            <glossterm>Covariant literals</glossterm>
            <glossdef>
                <para>
                    TODO
                </para>
            </glossdef>
        </glossentry>
        <glossentry>
            <glossterm>Axiom</glossterm>
            <glossdef>
                <para>
                    TODO
                </para>
            </glossdef>
        </glossentry>
    </glossary>
    
    <bibliography>
        <title>References</title>
        <bibliodiv>
            <title>Specifications</title>
            <biblioentry id="bib.xml">
                <abbrev>XML</abbrev>
                <title><ulink url="http://www.w3.org/TR/2008/REC-xml-20081126/">Extensible Markup Language (XML) 1.0 (Fifth Edition)</ulink></title>
                <publishername>W3C Recommendation</publishername>
                <pubdate>26 November 2008</pubdate>
            </biblioentry>
            <biblioentry id="bib.namespaces">
                <abbrev>Namespaces</abbrev>
                <title><ulink url="http://www.w3.org/TR/2009/REC-xml-names-20091208/">Namespaces in XML 1.0 (Third Edition)</ulink></title>
                <publishername>W3C Recommendation</publishername>
                <pubdate>8 December 2009</pubdate>
            </biblioentry>
            <biblioentry id="bib.xmlschema.part2">
                <abbrev>Schema-2</abbrev>
                <title><ulink url="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema Part 2: Datatypes Second Edition</ulink></title>
                <publishername>W3C Recommendation</publishername>
                <pubdate>28 October 2004</pubdate>
            </biblioentry>
            <biblioentry id="bib.infoset">
                <abbrev>XML-Infoset</abbrev>
                <title><ulink url="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/">XML Information Set (Second Edition)</ulink></title>
                <publishername>W3C Recommendation</publishername>
                <pubdate>4 February 2004</pubdate>
            </biblioentry>
        </bibliodiv>
    </bibliography>
</book>