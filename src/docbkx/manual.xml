<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book>
    <bookinfo>
        <title>DDOM Manual</title>
        <releaseinfo>&version;</releaseinfo>
        <legalnotice>
            <para>
                Copyright 2009 Andreas Veithen
            </para>
            <para>
                Licensed under the Apache License, Version 2.0 (the "License");
                you may not use this file except in compliance with the License.
                You may obtain a copy of the License at
            </para>
            <para>
                <ulink url="http://www.apache.org/licenses/LICENSE-2.0"/>
            </para>
            <para>
                Unless required by applicable law or agreed to in writing, software
                distributed under the License is distributed on an "AS IS" BASIS,
                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                See the License for the specific language governing permissions and
                limitations under the License.
            </para>
        </legalnotice>
    </bookinfo>
    
    <toc/>

    <part>
        <title>Architecture</title>
        <chapter>
            <title>Design goals</title>
            <para>
                High priority design goals:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The amount of new APIs created by the project should be as low as possible. In most of the
                        areas covered by this project, well defined, widely used and/or convenient APIs already
                        exist:
                    </para>
                    <table>
                        <tgroup cols="2">
                            <thead>
                                <row>
                                    <entry>Area</entry><entry>Existing APIs/frameworks</entry>
                                </row>
                            </thead>
                            <tbody>
                                <row>
                                    <entry>XML object models</entry>
                                    <entry>DOM, Axiom, JDOM, DOM4J, XOM</entry>
                                </row>
                                <row>
                                    <entry>SOAP object models</entry>
                                    <entry>SAAJ, Axiom, Spring WS</entry>
                                </row>
                                <row>
                                    <entry>XML data sources</entry>
                                    <entry>JAXP (<classname>SAXSource</classname>, <classname>DOMSource</classname>,
                                           <classname>StreamSource</classname>), SAX (<classname>InputSource</classname>)</entry>
                                </row>
                                <row>
                                    <entry>XML data stream</entry>
                                    <entry>StAX (pull), SAX (push)</entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </table>
                    <para>
                        The project should leverage existing APIs as much as possible and only introduce new APIs where
                        this is strictly necessary.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Medium priority design goals:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Many existing frameworks, in particular XML object models, are plagued by an issue related to
                        the <literal>xsd:QName</literal> type as defined by section 3.2.18 of
                        <biblioref linkend="bib.xmlschema.part2"/>.
                    </para>
                </listitem>
            </itemizedlist>
        </chapter>
        <chapter>
            <title>The Logical Content Model</title>
            <section>
                <title>Introduction</title>
                <para>
                    The <firstterm>Logical Content Model</firstterm> defines an abstract data set describing
                    the information contained in a well-formed XML document. The purpose is to provide a consistent
                    set of definitions used throughout the rest of the documentation. It is important to understand
                    that the Logical Content Model is not the same as the <firstterm>Object Model</firstterm> that
                    describes the data structures that are used to physically represent the content of an XML
                    document as Java objects. While similar in spirit, the Logical Content Model is also different
                    from the XML Information Set defined in <biblioref linkend="bib.infoset"/>. The Logical
                    Content Model can be best thought of as a model of the output of a typical XML parser, as well
                    as a model for the input of a typical XML serializer. The
                    following items give an overview of the relationship of the Logical Content Model to
                    the Object Model, XML Infoset and the output of an XML parser:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Since DDOM uses deferred parsing, the Object Model not only represents the the content
                            of the XML document, but must keep track of the state of the underlying parser.
                            On the other hand, the Logical Content Model is not concerned with deferred parsing and
                            describes a view of the entire document.
                        </para>
                        <para>
                            document fragments
                        </para>
                        <para>
                            non coalesced text nodes
                        </para>
                        <para>
                            namespace aware and unaware elements and attributes
                        </para>
                        <para>
                            CDATA sections -> not in the infoset
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            In the Logical Content Model, attribute values and element content (i.e. text nodes)
                            are described in term of lexical space. On the other hand, the Object Model may
                            store this content by referring to the value space of the corresponding type.
                            E.g. if the document is linked to an XML schema, then the Object Model may
                            use a <classname>java.xml.namespace.QName</classname> object to store the content
                            of an element or attribute declared with the <type>xs:QName</type> schema type.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            XML Infoset is not suitable to describe the output of a namespace unaware
                            parser. In order to support Object Models which allow manipulation of
                            XML in a namespace unaware way, the Logical Content Model defines specific
                            information items for output of namespace unaware parsers.
                        </para>
                    </listitem>
                </itemizedlist>
            </section>
            <section>
                <title>Information items</title>
                <section>
                    <title>The namespace unaware element information item</title>
                    <para>
                        A namespace unaware element information item is produced by a namespace unaware parser
                        for each <ulink url="http://www.w3.org/TR/REC-xml/#NT-element"><literal>element</literal></ulink>
                        appearing in the document. It has the following properties:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>[name]</term>
                            <listitem>The <ulink url="http://www.w3.org/TR/REC-xml/#NT-Name"><literal>Name</literal></ulink> of the element.</listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        When a namespace unaware element information item is serialized, it is written as-is, without
                        consideration for the namespace declarations that are in scope at the location
                        where the element is written.
                    </para>
                    <note>
                        <para>
                            This has important consequences if the resulting document is later
                            parsed by a namespace aware parser. The behavior depends on the
                            structure of its name:
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>
                                    If the name is an <ulink url="http://www.w3.org/TR/REC-xml-names/#NT-NCName"><literal>NCName</literal></ulink>,
                                    the it will pick up the default namespace in scope. Since a default namespace
                                    always exists, the element is always namespace well-formed.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    If the name is a <ulink url="http://www.w3.org/TR/REC-xml-names/#NT-PrefixedName"><literal>PrefixedName</literal></ulink>,
                                    then it will pick up the namespace bound to the corresponding prefix.
                                    If no corresponding namespace declaration is in scope, the element
                                    is not namespace well-formed.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    Otherwise the element is never namespace well-formed.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <para>
                            This implies that a namespace unaware element information item may never
                            be considered to have a well-defined namespace.
                        </para>
                    </note>
                </section>
                <section>
                    <title>The namespace unaware attribute information item</title>
                    <para>
                        A namespace unaware attribute information item is produced by a namespace unaware parser
                        for each <ulink url="http://www.w3.org/TR/REC-xml/#NT-Attribute"><literal>Attribute</literal></ulink>
                        appearing in the document. It has the following properties:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>[name]</term>
                            <listitem>The <ulink url="http://www.w3.org/TR/REC-xml/#NT-Name"><literal>Name</literal></ulink> of the attribute.</listitem>
                        </varlistentry>
                    </variablelist>
                    <para>
                        When a namespace unaware attribute information item is serialized, it is written as-is, without
                        consideration for the namespace declarations that are in scope at the location
                        where the element is written.
                    </para>
                    <note>
                        <para>
                            The consequences of this are slightly different than for namespace unaware elements:
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>
                                    If the name is an <ulink url="http://www.w3.org/TR/REC-xml-names/#NT-NCName"><literal>NCName</literal></ulink>,
                                    the the attribute will be namespace well-formed and have no namespace.
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    If the name is not an <literal>NCName</literal>, then the attribute will be
                                    either not namespace well-formed or it will pick up the namespace of one
                                    of the namespace declarations in scope, exactly as for namespace unaware
                                    elements.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <para>
                            The important point to note here is that in contrast to namespace unaware elements,
                            a namespace unaware attribute has a well-defined namespace if its name is a
                            <literal>NCName</literal>. This is also true if the name is a
                            <ulink url="http://www.w3.org/TR/REC-xml-names/#NT-PrefixedName"><literal>PrefixedName</literal></ulink>
                            with <literal>xml</literal> as prefix, because this prefix is always implicitly
                            bound to <literal>http://www.w3.org/XML/1998/namespace</literal> (and
                            must not be bound to any other namespace).
                            There is thus a partial equivalence between namespace unaware and
                            namespace aware attribute information items.
                        </para>
                    </note>
                </section>
            </section>
        </chapter>
    </part>
    <part>
        <title>Developer guide</title>
        <chapter>
            <title>Backend development</title>
            
            <section>
                <title>Backend implementations and deferred parsing</title>
                <para>
                    If loading existing documents is supported<footnote><para>This may not be the
                    case for proxy backends.</para></footnote>, it is the responsibility of the
                    backend to implement deferred parsing. The component managing the on-demand
                    parsing and creation of nodes is called <firstterm>builder</firstterm> (see
                    for example the <classname>Builder</classname> class in the linked list
                    backend). There are several reasons why the builder implementation is
                    considered backend specific:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The node object lifecycle is backend specific. Some backends may create
                            nodes eagerly, i.e. immediately after reception of an XML event from
                            the underlying parser. Other backends may store the data in another
                            data structure and defer creation of the corresponding nodes until they
                            are actually accessed.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The builder will typically create nodes directly, without going through
                            the node factory. One reason is that names, namespace URIs and prefixes
                            received from the underlying parser are already canonicalized.
                        </para>
                    </listitem>
                </itemizedlist>
                <note>
                    <para>
                        The fact that the builder is part of the backend implementation and not
                        a generic component is a major architectural difference with respect to
                        Axiom, where the <classname>StAXOMBuilder</classname> class is used by
                        all implementations.
                    </para>
                </note>
            </section>
        </chapter>
        <chapter>
            <title>Background material</title>
            <section>
                <title>Namespace unaware XML processing</title>
                <para>
                    ...
                </para>
            </section>
            <section>
                <title>Covariant literals</title>
                <para>
                    ...
                </para>
            </section>
            <section>
                <title>The StAX specification</title>
                <para>
                    The StAX specification comprises two parts: a specification document titled <quote>Streaming API
                    For XML JSR-173 Specification</quote> and a Javadoc describing the API. Both can be downloaded from the
                    <ulink url="http://jcp.org/en/jsr/detail?id=173">JSR-173 page</ulink>. Since StAX is part of Java 6,
                    the Javadocs can also be viewed
                    <ulink url="http://java.sun.com/javase/6/docs/api/javax/xml/stream/package-summary.html">online</ulink>. 
                </para>
                <section>
                    <title>Semantics of the <methodname>setPrefix</methodname> method</title>
                    <para>
                        Probably one of the more obscure parts of the StAX specifications is the meaning of the
                        <methodname>setPrefix</methodname><footnote><para>For simplicity, we only discuss
                        <methodname>setPrefix</methodname> here. The same remarks also apply to
                        <methodname>setDefaultNamespace</methodname>.</para></footnote> method defined by <classname>XMLStreamWriter</classname>.
                        To understand how this method works, it is necessary to look at different parts of the specification:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The Javadoc of the <methodname>setPrefix</methodname> method.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The table shown in the Javadoc of the <classname>XMLStreamWriter</classname> class
                                in Java 6<footnote><para>This table is not included in the Javadoc in the original StAX
                                specification.</para></footnote>.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Section 5.2.2, <quote>Binding Prefixes</quote> of the specification.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The example shown in section 5.3.2, <quote>XMLStreamWriter</quote> of the specification.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        In addition, it is important to note the following facts:
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The terms <firstterm>defaulting prefixes</firstterm> used in section 5.2.2 of the
                                specification and <firstterm>namespace repairing</firstterm> used in the Javadocs
                                of <classname>XMLStreamWriter</classname> are synonyms.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The methods writing namespace qualified information items, i.e.
                                <methodname>writeStartElement</methodname>, <methodname>writeEmptyElement</methodname>
                                and <methodname>writeAttribute</methodname> all come in two variants: one that
                                takes a namespace URI and a prefix as arguments and one that only takes a
                                namespace URI, but no prefix.
                            </para>
                        </listitem>
                    </itemizedlist>
                    <para>
                        The purpose of the <methodname>setPrefix</methodname> method is simply to define the prefixes that
                        will be used by the variants of the <methodname>writeStartElement</methodname>,
                        <methodname>writeEmptyElement</methodname> and <methodname>writeAttribute</methodname> methods
                        that only take a namespace URI (and the local name). This becomes clear by looking at the
                        table in the <classname>XMLStreamWriter</classname> Javadoc. Note that a call to
                        <methodname>setPrefix</methodname> doesn't cause any output and it is still necessary
                        to use <methodname>writeNamespace</methodname> to actually write the necessary
                        namespace declarations. Otherwise the produced document will not be well formed with
                        respect to namespaces.
                    </para>
                    <para>
                        The Javadoc of the <methodname>setPrefix</methodname> method also clearly defines the scope
                        of the prefix bindings defined using that method: a prefix bound using
                        <methodname>setPrefix</methodname> remains valid till the invocation of
                        <methodname>writeEndElement</methodname> corresponding to the last invocation of
                        <methodname>writeStartElement</methodname>. While not explicitly mentioned in the
                        specifications, it is clear that a prefix binding may be masked by another binding
                        for the same prefix defined in a nested element.
                    </para>
                    <para>
                        An aspect that may cause confusion is the fact that in the example shown in section
                        5.3.2 of the specifications, the calls to <methodname>setPrefix</methodname> (and
                        <methodname>setDefaultNamespace</methodname>) all appear immediately before a
                        call to <methodname>writeStartElement</methodname> or <methodname>writeEmptyElement</methodname>.
                        This may lead people to incorrectly believe that a prefix binding defined using
                        <methodname>setPrefix</methodname> only applies to the next element
                        written<footnote><para>Another factor that contributes to the confusion is that in SAX,
                        prefix mappings are always generated before the corresponding <methodname>startElement</methodname>
                        event and that their scope ends with the corresponding <methodname>endElement</methodname>
                        event. This is so because the <classname>ContentHandler</classname> interface specifies that
                        <quote>all <methodname>startPrefixMapping</methodname> events will occur immediately before the
                        corresponding <methodname>startElement</methodname> event, and all <methodname>endPrefixMapping</methodname>
                        events will occur immediately after the corresponding <methodname>endElement</methodname>
                        event</quote>.</para></footnote>.
                        This interpretation is clearly in contradiction with the <methodname>setPrefix</methodname>
                        Javadoc, unless one assumes that <quote>the current START_ELEMENT / END_ELEMENT pair</quote>
                        means the element opened by a call to <methodname>writeStartElement</methodname> immediately following
                        the call to <methodname>setPrefix</methodname>. This however would be a very arbitrary interpretation
                        of the Javadoc<footnote><para>Early versions of XL XP-J were based on this interpretation of the
                        specifications, but this has been corrected. Versions conforming to the specifications support
                        a special property called <varname>javax.xml.stream.XMLStreamWriter.isSetPrefixBeforeStartElement</varname>,
                        which always returns <code>Boolean.FALSE</code>. This allows to easily distinguish the non
                        conforming versions from the newer versions. Note that in contrast to what the usage of the reserved
                        <literal>javax.xml.stream</literal> prefix suggests, this is a vendor specific property that
                        is not supported by other implementations.</para></footnote>.
                    </para>
                    <para>
                        The correctness of the comments in the previous paragraph can be checked using the following
                        code snippet:
                    </para>
<programlisting>XMLOutputFactory f = XMLOutputFactory.newInstance();
XMLStreamWriter writer = f.createXMLStreamWriter(System.out);
writer.writeStartElement("root");
writer.setPrefix("p", "urn:ns1");
writer.writeEmptyElement("urn:ns1", "element1");
writer.writeEmptyElement("urn:ns1", "element2");
writer.writeEndElement();
writer.flush();
writer.close();</programlisting>
                    <para>
                        This produces the following output<footnote><para>This has been tested with
                        Woodstox 3.2.9, SJSXP 1.0.1 and version 1.2.0 of the reference
                        implementation.</para></footnote>:
                    </para>
<screen><![CDATA[<root><p:element1/><p:element2/></root>]]></screen>
                    <para>
                        Since the code doesn't call <methodname>writeNamespace</methodname>, the output is obviously not
                        well formed with respect to namespaces, but it also clearly shows that the scope of the
                        prefix binding for <literal>p</literal> extends to the end of the
                        <sgmltag class="element">root</sgmltag> element and is not limited to
                        <sgmltag class="element">element1</sgmltag>.
                    </para>
                    <para>
                        To avoid unexpected results and keep the code maintainable, it is in general advisable to keep
                        the calls to <methodname>setPrefix</methodname> and <methodname>writeNamespace</methodname> aligned,
                        i.e. to make sure that the scope (in <classname>XMLStreamWriter</classname>) of the prefix binding
                        defined by <methodname>setPrefix</methodname> is compatible with the scope (in the produced
                        document) of the namespace declaration written by the corresponding call
                        to <methodname>writeNamespace</methodname>. This makes it necessary to write code like this:
                    </para>
<programlisting>writer.writeStartElement("p", "element1", "urn:ns1");
writer.setPrefix("p", "urn:ns1");
writer.writeNamespace("p", "urn:ns1");</programlisting>
                    <para>
                        As can be seen from this code snippet, keeping the two scopes in sync makes it necessary to use
                        the <methodname>writeStartElement</methodname> variant which takes an explicit prefix. Note that
                        this somewhat conflicts with the purpose of the <methodname>setPrefix</methodname> method;
                        one may consider this as a flaw in the design of the StAX API.
                    </para>
                </section>
                <section>
                    <title>The three <classname>XMLStreamWriter</classname> usage patterns</title>
                    <para>
                        Drawing the conclusions from the previous section and taking into account that
                        <classname>XMLStreamWriter</classname> also has a <quote>namespace repairing</quote>
                        mode, one can see that there are in fact three different ways to use
                        <classname>XMLStreamWriter</classname>. These usage patterns correspond to the
                        three bullets in section 5.2.2 of the StAX specification<footnote><para>The content
                        of this section is largely based on a <ulink url="http://markmail.org/message/olsdl3p3gciqqeob">reply
                        posted by Tatu Saloranta on the Axiom mailing list</ulink>. Tatu is the main developer of the
                        Woodstox project.</para></footnote>:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                In the <quote>namespace repairing</quote> mode (enabled by the
                                <varname>javax.xml.stream.isRepairingNamespaces</varname> property), the writer
                                takes care of all namespace bindings and declarations, with minimal help from
                                the calling code. This will always produce output that is well-formed with respect
                                to namespaces. On the other hand, this adds some overhead and the result may
                                depend on the particular StAX implementation (though the result produced by
                                different implementations will be equivalent).
                            </para>
                            <para>
                                In repairing mode the calling code should avoid writing namespaces explicitly
                                and leave that job to the writer. There is also no need to call
                                <methodname>setPrefix</methodname>, except to suggest a preferred prefix for
                                a namespace URI. All variants of <methodname>writeStartElement</methodname>,
                                <methodname>writeEmptyElement</methodname> and <methodname>writeAttribute</methodname>
                                may be used in this mode, but the implementation can choose whatever prefix mapping
                                it wants, as long as the output results in proper URI mapping for elements and
                                attributes.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Only use the variants of the writer methods that take an explicit prefix together
                                with the namespace URI. In this usage pattern, <methodname>setPrefix</methodname>
                                is not used at all and it is the responsibility of the calling code to keep
                                track of prefix bindings.
                            </para>
                            <para>
                                Note that this approach is difficult to implement when different parts of the output document
                                will be produced by different components (or even different libraries). Indeed, when
                                passing the <classname>XMLStreamWriter</classname> from one method or component
                                to the other, it will also be necessary to pass additional information about the
                                prefix mappings in scope at that moment, unless the it is acceptable to let the
                                called method write (potentially redundant) namespace declarations for all namespaces
                                it uses.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Use <methodname>setPrefix</methodname> to keep track of prefix bindings and make sure that
                                the bindings are in sync with the namespace declarations that have been written,
                                i.e. always use <methodname>setPrefix</methodname> immediately before or immediately
                                after each call to <methodname>writeNamespace</methodname>. Note that the code is
                                still free to use all variants of <methodname>writeStartElement</methodname>,
                                <methodname>writeEmptyElement</methodname> and <methodname>writeAttribute</methodname>;
                                it only needs to make sure that the usage it makes of these methods is consistent with
                                the prefix bindings in scope.
                            </para>
                            <para>
                                The advantage of this approach is that it allows to write modular code: when a
                                method receives an <classname>XMLStreamWriter</classname> object (to write
                                part of the document), it can use
                                the namespace context of that writer (i.e. <methodname>getPrefix</methodname>
                                and <methodname>getNamespaceContext</methodname>) to determine which namespace
                                declarations are currently in scope in the output document and to avoid
                                redundant or conflicting namespace declarations. Note that in order to do so,
                                such code will have to check for an existing prefix binding before starting
                                to use a namespace.
                            </para>
                        </listitem>
                    </orderedlist>
                </section>
            </section>
        </chapter>
    </part>
        
    <bibliography>
        <title>References</title>
        <bibliodiv>
            <title>Specifications</title>
            <biblioentry id="bib.xmlschema.part2">
                <abbrev>Schema-2</abbrev>
                <title><ulink url="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema Part 2: Datatypes Second Edition</ulink></title>
                <publishername>W3C Recommendation</publishername>
                <pubdate>28 October 2004</pubdate>
            </biblioentry>
            <biblioentry id="bib.infoset">
                <abbrev>XML-Infoset</abbrev>
                <title><ulink url="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/">XML Information Set (Second Edition)</ulink></title>
                <publishername>W3C Recommendation</publishername>
                <pubdate>4 February 2004</pubdate>
            </biblioentry>
        </bibliodiv>
    </bibliography>
</book>