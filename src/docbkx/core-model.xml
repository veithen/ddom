<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter SYSTEM "manual.dtd">
<chapter>
    <title>The Core Model</title>
    <para>
        The Core Model is a mapping of the Logical Content Model defined in <xref linkend="lcm"/>
        into a set of interfaces in the Java language. The Core Model is thus an abstract API.
        The mapping between the two models is mostly direct, but there are some slight
        differences that will be explained in the following sections.
    </para>
    <section>
        <title>Document fragments</title>
        <para>
            While the Logical Content Model is a model of the content of a well-formed
            XML document, the Core Model is an API that allows user code to manipulate,
            edit and create XML documents. To allow these manipulations, it is necessary
            to introduce a node type that has no corresponding information item.
            This node type is called <firstterm>document fragment</firstterm> and
            represents an arbitrary sequence of nodes. Together, these nodes do not
            necessarily constitute a well formed document. E.g. the sequence may contain
            an arbitrary number of element nodes. 
        </para>
    </section>
    <section>
        <title>Owner documents and node factories</title>
        <para>
            APIs implementing XML object models can be classified into three categories:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    Some APIs require that a node must always be linked to a document instance, even
                    if it is not an ancestor of that document. In these APIs it is not possible
                    to create a node that is completely detached from any other model object, the
                    only exception being the document instance itself. An example is DOM where every node
                    must be linked a single <classname>Document</classname> instance (except for
                    <classname>DocumentType</classname> nodes created from a <classname>DOMImplementation</classname>).
                    DOM enforces this by defining the factory methods for node instances on the
                    <classname>Document</classname> interface, so that a node can only be created
                    from an existing <classname>Document</classname> instance.
                </para>
                <para>
                    For consistency, in this type of API, all nodes linked by parent-child (or element-attribute)
                    relationships must belong to the same owner document. Therefore, moving a node from one document to another
                    is a different operation than moving a node within the same document. E.g. in
                    DOM, nodes must be "imported" or "adopted" before they can be used in a
                    different document instance.
                </para>
            </listitem>
            <listitem>
                <para>
                    Some APIs use a factory pattern to create nodes and in addition require that each node keeps
                    a reference to the factory that created it. Depending on whether the factory is stateless
                    and thread safe, it may or may not be implemented as a singleton.
                </para>
                <para>
                    Axiom is an example of this kind of API. The reason is that it uses different factories
                    for different SOAP versions, as well as a separate factory for plain XML documents. The factories
                    for the two SOAP versions implement the same interface which extends the interface implemented
                    by the factory for plain XML documents.
                </para>
                <para>
                    The default (LLOM) implementation uses singleton factories, while for the DOOM implementation
                    the factories need to be considered as stateful (because each instance keeps a reference to
                    the document so that it can provide compatibility with DOM, which uses a different API style,
                    as explained above).
                </para>
                <para>
                    Another particularity of Axiom is that nodes in the same tree (i.e. linked by parent-child or
                    element-attribute relationships) are not necessarily linked to the same factory. Axiom only
                    enforces compatibility between the factories used in the same tree. For example it is possible
                    to add a node created by a plain XML factory to a node created using a SOAP factory, provided
                    that the two factories are from the same implementation (LLOM or DOOM).
                </para>
            </listitem>
            <listitem>
                <para>
                    In other APIs a node is neither required to have a reference to a document nor to a factory.
                    JDOM is an example of this type of API. It uses concrete classes that can be instantiated using
                    public constructors, i.e. there is no factory. Part of the SAAJ API also uses this API style,
                    but with a factory (<classname>SOAPFactory</classname>). However, since SAAJ is an extension of
                    DOM, a node created by this factory still has a property that links it to an owner document.
                    Sun's reference implementation resolves this contradiction by creating a document instance for
                    each node created by the factory. This document instance is discarded when the node is added to
                    the target document.
                </para>
            </listitem>
        </orderedlist>
        <para>
            In the last two cases, a node only becomes linked to a particular document instance when it is added to a parent
            that is part of a tree which has a document as its root node. It should be noted that a large number of operations
            may be carried out on the node or its descendants before this actually happens.
            In the extreme case, the entire content of the document is constructed before
            the document element is added to a particular document instance. Some APIs (such as Axiom) also
            support serializing elements so that it is even not required to create a document instance.
        </para>
        <para>
            To support front-ends using any of the API styles identified above, the Core Model is designed around the
            following assumptions:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A node may be linked to an owner document, but this is not required.
                    In contexts where an owner document is needed, one will be created automatically.
                </para>
            </listitem>
            <listitem>
                <para>
                    If a node has a parent, then the owner document of the node must be the same as
                    the owner document of the parent. Similarly, if an attribute is owned by an element, then
                    the owner document of the attribute must be the same as the owner document of the element.
                </para>
            </listitem>
            <listitem>
                <para>
                    A document instance has itself as an owner document.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            A corollary of these rules is that explicit knowledge of the owner document is only required for
            nodes that have no parent. To determine the owner document of a node that has a parent, it is
            sufficient to iterate over the ancestors until reaching a document node (which is then the owner
            document) or a node that has no parent (for which the owner document is then known explicitly).
        </para>
        <para>
            The Core Model also has a concept of <firstterm>node factory</firstterm>. This factory is a
            singleton. More precisely, because of the weaving process (which generates different node factory
            implementations), there is one and only one node factory for each model (i.e. combination of
            back-end end front-ends).
        </para>
        <tip>
            <para>
                As a side note, this implies that in order to check whether a given node belongs to
                the right model and can be added to the tree without conversion, a back-end implementation
                may invariably use the <literal>instanceof</literal> operator or compare the identity of
                the node factories.
            </para>
        </tip>
        <para>
            Because of the singleton nature, the concept of node factory used by the Core Model doesn't
            match the factory concept in Axiom. On the other hand, in terms of lifecycle, it is equivalent
            to Axiom's <classname>OMMetaFactory</classname> concept.
        </para>
    </section>
    <section id="compact.parents">
        <title>Compact parent nodes</title>
        <para>
            The Logical Content Model defines the children property as an ordered list
            of child information items. The direct transcription of this would be to
            specify that a parent node is a node that has an ordered list of child nodes.
            There are several reasons why this is too simplistic:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <xref linkend="tbl.lcm.parent-child-leaf"/> shows that most nodes are
                    actually parent nodes. In practice however, many instances of parent
                    nodes will only contain a single text node as their child. This is
                    certainly true for attributes, CDATA sections, comments and
                    processing instructions. Surprisingly, this is also true for elements,
                    especially in SOAP messages. Indeed, in a typical Web service message,
                    most elements are instances of simple schema types, and thus
                    contain a single text information item (unless the element is empty or
                    the parser decides to segment the value of the element).
                </para>
                <para>
                    Storing this character data in separate node instances creates an
                    overhead that in most cases is unnecessary because the text node will
                    never be accessed directly. Instead, the application typically uses
                    a method on the parent node to retrieve its text content.
                    E.g. for elements, the following methods can be used, depending on
                    the API:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            DOM: <methodname>Node#getTextContent()</methodname> invoked on
                            the <classname>Element</classname> instance.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Axiom: <methodname>OMElement#getText()</methodname>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            StAX: <methodname>XMLStreamReader#getElementText()</methodname>.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    In the case of attributes, CDATA sections, comments and processing
                    instructions, some APIs even don't have methods to
                    access the child nodes because they don't consider these nodes as
                    parent nodes. Especially for attributes, the overhead created
                    by storing their values in separate child nodes would be
                    annoying.
                </para>
            </listitem>
            <listitem>
                <para>
                    The Logical Content Model only captures the content of a document,
                    but not its semantics. In particular, if the document is described
                    by an XML schema, then for simple types, the Logical Content Model
                    only refers to the lexical space but never to the value
                    space of these types.
                    To support frontends such as Axiom [and SDO??], it is necessary 
                    to allow the Core Model to store content using objects other than
                    strings.
                </para>
            </listitem>
            <listitem>
                <para>
                    One of the design goals is to support sourced content.
                    [TODO: (link to) definition here]
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Therefore, the design of the Core Model specifies that the content of a parent
            node may be stored in one of the following forms:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    As an order list of child nodes.
                </para>
            </listitem>
            <listitem>
                <para>
                    As a <firstterm>value object</firstterm>, i.e. a single String object or
                    an object of another type that has a well-defined mapping from value to lexical space. Examples are
                    <classname>javax.xml.namespace.QName</classname> for <type>xs:QName</type>
                    and <classname>javax.activation.DataHandler</classname> for <type>xs:base64Binary</type>.
                </para>
            </listitem>
            <listitem>
                <para>
                    An object of type <classname>FragmentSource</classname>.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            An instance that stores its content as an order list of child nodes is said to
            be <firstterm>expanded</firstterm>. If it uses one of the other two representations,
            it is said to be <firstterm>unexpanded</firstterm>. When the children of an
            unexpanded parent node are queried, the node will be <firstterm>expanded</firstterm>,
            i.e. the alternative representation will be replaced by an equivalent list of
            child nodes. Node types supporting this mechanism are called
            <firstterm>compact</firstterm>. Note that in the Core Model, all parent nodes
            are compact [Well, not yet...].
        </para>
        <para>
            If the content is stored using a <classname>FragmentSource</classname>, then
            deferred parsing is used when the node is expanded. This means that after
            expansion, the list of child nodes may be incomplete and only contain the
            materialized child nodes. Of course this is transparent to the code
            interacting with the Core Model.
        </para>
        <para>
            In this context it is important not to confuse the concept
            of "expanded" with the concept of "complete".
            [TODO: elaborate a bit more; it is clear that an incomplete node may be expanded;
            but may a complete node become incomplete when it is expanded?!?] 
        </para>
        <para>
            TODO: specify what happens to value objects after expansion!
        </para>
    </section>
    <section>
        <title>Read-only nodes</title>
        <para>
            For consistency during serialization, modifying the descendants of an entity
            reference node is disallowed. Since this is the only case of read-only nodes,
            it is specified that a node is read-only if and only if it is an entity
            reference node or a descendant of an entity reference node. It is the
            responsibility of the backend to enforce this.
        </para>
        <para>
            One can see that there are three different ways to implement this behavior:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Let the each node have an attribute that indicates
                    if it is read-only and set this attribute appropriately.
                </para>
            </listitem>
            <listitem>
                <para>
                    Explicitly check if the node has an ancestor which is an entity
                    reference.
                </para>
            </listitem>
            <listitem>
                <para>
                    Let parent nodes have an explicit flag and let leaf nodes (i.e. text nodes) check
                    if they are children of a read-only node.
                </para>
            </listitem>
        </itemizedlist>
    </section>
    <section>
        <title>Document models</title>
        <para>
            In general, an XML object model is agnostic to the actual document type that it represents,
            i.e. it doesn't matter to the object model implementation whether the document is a SOAP message or
            a DocBook document. The content is just a collection of information items organized in a
            tree structure. In some cases, information about the content may be supplied by a DTD or an XML
            schema. However, there are cases where this is insufficient or where supplying a DTD or schema
            is not an option because it would introduce too much overhead. Here are a few sample use cases
            where the object model needs information about the expected structure of the XML document
            but where using a DTD or schema is not possible:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Some APIs use domain specific interfaces to represent certain elements (or other
                    information items). For example, SAAJ uses <classname>SOAPEnvelope</classname> to
                    represent the envelope appearing in a SOAP message. In DDOM this is supported by the
                    concept of <firstterm>model extensions</firstterm>. <xref linkend="model-extensions"/>
                    explains how a front-end can define a model extension and how the corresponding
                    implementation classes are generated by the weaver.
                    However, for this feature to be complete, the object model (and in particular the
                    builder) must know which extension interface to use for which element.
                    There are different possible cases:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            In some cases, the interface to be used is simply determined by the
                            element's (qualified) name. For example, SAAJ always creates a
                            <classname>SOAPEnvelope</classname> if it is requested to create element
                            with local name <literal>Envelope</literal> and a namespace URI that
                            matches the envelope namespace of SOAP 1.1 or SOAP 1.2.
                        </para>
                        <note>
                            <para>
                                Axiom's behavior is slightly different: a <classname>SOAPEnvelope</classname>
                                implementation is only created if requested explicitly or during parsing,
                                if the element has the correct name <emphasis role="strong">and</emphasis>
                                if it is the root element of the document. 
                            </para>
                        </note>
                    </listitem>
                    <listitem>
                        <para>
                            In other cases, the interface to be used also depends on the position of
                            the element in the document. E.g. SAAJ creates <classname>SOAPHeaderElement</classname>
                            implementations for all child elements of the header element, regardless of
                            their name.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    Thus, in any case, to support the model extension feature, the object model requires
                    knowledge about the expected structure of the document.
                </para>
            </listitem>
            <listitem>
                <para>
                    As explained in <xref linkend="covariant-literals"/> the existence of attribute
                    or text information items containing <literal>QName</literal> literals in some cases causes problems
                    because the information contained in these literals may be lost if for some
                    reasons the namespace context changes while manipulating the document.
                    An example of this is the <sgmltag class="attribute">xsi:type</sgmltag> attribute.
                    This is a standard XML attribute of type <literal>QName</literal>. It is important
                    to preserve the value (but not necessarily its literal representation) of this
                    attribute because it is used by databindings to select the right class corresponding
                    to the schema type of an element.
                </para>
                <para>
                    This problem appeared in Axiom and was described by WSCOMMONS-496. The retained solution
                    was to hardcode the logic specific to that particular case, which is now burned into
                    one of Axiom's internal classes (see the change in revision 806373).
                </para>
            </listitem>
            <listitem>
                <para>
                    The WS-Security and related specifications make use of ID attributes and some DOM based
                    implementations of these standard use the <methodname>getElementById</methodname>
                    method to locate elements using ID attributes. The problem is that normally,
                    ID attributes are identified by the DTD or schema, i.e. it is not possible
                    to decide whether an attribute is an ID attribute or not simply by looking
                    at the attribute's name<footnote><para>See <ulink url="http://www.xml.com/lpt/a/2001/11/07/id.html"/>
                    for a general discussion about the implications of this.</para></footnote>.
                    DOM strictly enforces this, i.e. <methodname>getElementById</methodname>
                    will only look at attributes that during parsing have been identified as ID attributes
                    based on DTD or schema information, or that have been set using the
                    <methodname>setIdAttribute</methodname>, <methodname>setIdAttributeNS</methodname>
                    or <methodname>setIdAttributeNode</methodname> method (defined by DOM level 3).
                </para>
                <para>
                    Since for performance reasons, DTD or schema processing is not an option in
                    SOAP implementations, and since the possibility to explicitly mark an attribute
                    as ID attribute only exists in DOM level 3, various workarounds have been
                    implemented to address this issue:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            Apache Santuario has a mechanism to explicitly mark attributes
                            as ID attributes. This information is stored outside of the DOM tree.
                            See the <classname>org.apache.xml.security.utils.IdResolver</classname>
                            class for more information.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Sun's SAAJ reference implementation automatically marks an attribute
                            set using <methodname>setAttributeNS</methodname> as ID attribute
                            if its name matches one of the names used for ID attributes in
                            the XML Signature, XML Encryption or WS-Security specifications
                            (see the code in the <methodname>setAttributeNS</methodname> method in
                            <classname>com.sun.xml.messaging.saaj.soap.impl.ElementImpl</classname>).
                            Thus, knowledge about the expected content of the document is hardcoded
                            into the SAAJ implementation.
                        </para>
                    </listitem>
                </itemizedlist>
            </listitem>
            <listitem>
                <para>
                    It is notoriously difficult to efficiently process binary data encoded
                    as <type>xs:base64Binary</type> values, unless XOP or MTOM is used to externalize
                    this data. There are several challenges:
                </para>
                <itemizedlist>
                    <listitem>
                        <para>
                            The number of characters necessary to represent a sequence of N bytes
                            using base64 encoding is 4*N/3 (not including padding). Since Java uses
                            16 bit characters, this causes an overhead of 8/3-1 = 167%.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            If the underlying parser is non coalescing and the base64 decoding is not
                            done properly (or if the parser is coalescing), then a string concatenation
                            is required before the data can be decoded. This may introduce significant
                            overhead if the volume of binary data is high.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            While for XOP optimized binary data it is easy to implement streaming and
                            offloading to disk, only a few object models and SOAP stacks support this
                            for inlined base64 encoded binary data.
                        </para>
                    </listitem>
                </itemizedlist>
                <para>
                    If the object model has no external information about the structure of the
                    document, then optimizations can only be done if requested explicitly
                    by the code attempting to access the <type>xs:base64Binary</type> value,
                    and then only if the relevant part of the object model has not been build before.
                </para>
                <para>
                    To do more sophisticated optimizations, it is necessary for the object model
                    implementation to know in advance where in the document <type>xs:base64Binary</type>
                    values may appear.
                </para>
            </listitem>
        </itemizedlist>
    </section>
    <section>
        <title>UML diagram</title>
        
    </section>
    <section>
        <title>Interface design</title>
        <para>
            The following principles and guidelines have been applied in the design of the
            Core Model API:
        </para>
        <orderedlist>
            <listitem>
                <para>
                    All interfaces representing nodes have names starting with <literal>Core</literal>.
                    More precisely, this convention applies to all interfaces that (after weaving)
                    may be implemented by a class that at the same time implements an interface
                    from the frontend API. While not strictly necessary, this convention makes it
                    easy to distinguish interfaces from the two APIs (e.g. <classname>CoreElement</classname>
                    and DOM's <classname>Element</classname> interface).
                </para>
            </listitem>
            <listitem>
                <para>
                    All methods defined by the interfaces identified in the previous item have names
                    starting with <literal>core</literal>. This is necessary to avoid any possible conflict
                    with methods defined by frontend APIs.
                </para>
            </listitem>
            <listitem>
                <para>
                    Several methods operate on more than one node. E.g., inserting a node requires
                    references to two nodes, namely the node to insert and the node defining the
                    position in the document (typically the future parent or sibling). In these cases
                    there are several possible ways to define the method. Depending on the selected
                    definition, the node on which the method must be invoked and the parameters
                    passed to the call vary. E.g. a method that inserts a new sibling may either be
                    defined such that it is invoked on the existing node or such that it is invoked
                    on the node to be inserted.
                </para>
                <para>
                    The guideline is to define methods such that they will be invoked on node instances
                    already part of the tree (and that don't change position) and that the parameter
                    represents the node to insert into the tree. In any case, redundancies such as
                    in the definition of DOM's <methodname>insertBefore</methodname> method (which must
                    be invoked on the parent node of the two nodes) should be strictly avoided.
                </para>
                <para>
                    One of the rationale for this guideline is that before actually inserting the node into the
                    tree, the Core Model implementation must make sure that it is an instance from the same
                    model<footnote><para>Note that because of weaving, it is not sufficient for the node to belong
                    to the same backend implementation.</para></footnote>, is owned by the same document and is
                    detached. In most cases, the backend implementation will also have to cast the parameters
                    of the method to the actual implementation classes. This can be conveniently combined
                    with the same-model check. Taking these different aspects into account, one can easily
                    see that the guideline described here produces to the most natural implementation code.
                </para>
            </listitem>
            <listitem>
                <para>
                    A method should only return a node instance if it is expected that the frontend code
                    actually needs the returned reference. If this is not the case, the method should
                    have a parameter that allows the frontend to specify if it requires a return value.
                    For methods that return a reference that in some cases is only used in null checks,
                    alternative methods returning booleans should be defined. An example for this is the
                    method that returns the parent of a node.
                </para>
                <para>
                    The rationale for this guideline is that some backend implementation not only defer
                    parsing, but may also defer the instantiation of the objects representing the
                    information items of the document. In that case, instatiation should only occur
                    if the frontend really needs the reference to the node instance.
                </para>
            </listitem>
        </orderedlist>
    </section>
</chapter>
