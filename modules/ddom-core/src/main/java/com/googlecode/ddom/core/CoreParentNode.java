/*
 * Copyright 2009-2011 Andreas Veithen
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.googlecode.ddom.core;

import com.googlecode.ddom.stream.XmlInput;
import com.googlecode.ddom.stream.XmlSource;

public interface CoreParentNode extends CoreNode {
    /**
     * Determine if this parent node is complete.
     * 
     * @return <code>true</code> if the node is complete, <code>false</code> otherwise
     */
    boolean coreIsComplete();
    
    void coreBuild() throws DeferredParsingException;
    
    /**
     * 
     * either a String or a ChildNode
     * 
     * @return
     */
    Object coreGetContent();
    
    void coreSetContent(XmlSource source);
    
    // Temporarily marked as deprecated. In most cases coreGetTextContent should be used.
    // However, this method may later be changed to return objects (e.g. QNames).
    @Deprecated
    String coreGetValue() throws DeferredParsingException;
    
    /**
     * Set the content of this node to the given value. This will remove all children previously
     * owned by this element.
     * 
     * @param value
     *            the value to set
     * @throws DeferredParsingException
     *             If an error occurs during deferred parsing. This may happen because the method
     *             needs to discard all existing children of the node and this may require the
     *             parser to be advanced to the end of this node.
     */
    void coreSetValue(String value) throws DeferredParsingException;
    
    /**
     * Remove all children from this node.
     * 
     * @throws DeferredParsingException 
     */
    void coreClear() throws DeferredParsingException;
    
    String coreGetTextContent() throws DeferredParsingException;
    
    // TODO: specify behavior if the element neither has children nor a value
    boolean coreIsExpanded();
    
    CoreChildNode coreGetFirstChild() throws DeferredParsingException;
    CoreChildNode coreGetLastChild() throws DeferredParsingException;
    int coreGetChildCount() throws DeferredParsingException;

    /**
     * Get an {@link XmlInput} object for this node. This object can be used to serialize the
     * content of the node.
     * <p>
     * Structurally modifying the tree while the {@link XmlInput} object is in use will lead to
     * unpredictable results and should be avoided.
     * <p>
     * A single invocation of the {@link XmlInput#proceed()} method on the returned {@link XmlInput}
     * object will in general produce a limited number of events (typically only events
     * corresponding to information contained in a single node). However, this is not a strict
     * requirement and there are at least two exceptions to this rule:
     * <ul>
     * <li>If <code>preserve</code> is set to <code>false</code>, then at some point the returned
     * {@link XmlInput} implementation may start to simply pass through events from another
     * {@link XmlInput} implementation. In that case, the number of events produced by a single
     * invocation of {@link XmlInput#proceed()} is determined by the original {@link XmlInput}
     * instance.
     * <li>If one of the descendants of this node is unexpanded and has a {@link XmlSource}
     * that supports non destructive serialization, then instead of expanding that node and
     * synthesizing events from the expanded node, the returned {@link XmlInput} implementation will
     * request an {@link XmlInput} instance from the {@link XmlSource} and pass through events
     * generated by that instance. This occurs even if <code>preserve</code> is set to
     * <code>true</code>. Indeed, since the {@link XmlSource} is non destructive, it is still
     * possible to expand the node afterwards. On the other hand, if the {@link XmlSource} is
     * destructive, then this will only occur if <code>preserve</code> is <code>false</code> (but
     * this case is already covered by the first item).
     * </ul>
     * <p>
     * The event sequence produced by the returned {@link XmlInput} implementation is a literal
     * transformation of the information items in the subtree starting from the node on which this
     * method is invoked. In particular this means that the event sequence is not necessarily well
     * formed with respect to namespaces. Therefore, depending on the use case, it may be necessary
     * to transform this event sequence using a namespace repairing filter.
     * 
     * @param preserve
     *            Determines whether the content (descendants) of this node should be preserved. The
     *            value of this flag is only relevant if this node or one of its descendants is
     *            incomplete. If the flag is set to <code>true</code>, then consuming the
     *            {@link XmlInput} will build the remaining nodes as necessary. Otherwise, the nodes
     *            will not be built and an attempt to access these parts of the tree afterwards will
     *            result in an error.
     * @return the {@link XmlInput} object
     */
    XmlInput coreGetInput(boolean preserve);
    
    /**
     * Append a new child to the list of children of this parent node. If the node to be added
     * already has a parent node, it is first removed from this parent.
     * 
     * @param newChild
     *            the new child; this may either be a {@link CoreChildNode} or a
     *            {@link CoreDocumentFragment}
     * @param policy
     *            the policy to apply if the new child already has a parent or belongs to a
     *            different document
     * @throws CoreModelException
     *             TODO: specify the exceptions
     * @throws WrongDocumentException
     *             if <code>newChild</code> belongs to a different document
     */
    void coreAppendChild(CoreChildNode newChild, NodeMigrationPolicy policy) throws HierarchyException, NodeMigrationException, DeferredParsingException;
    
    /**
     * 
     * @param newChildren
     * @throws CoreModelException
     * @throws WrongDocumentException
     *             if <code>newChildren</code> belongs to a different document
     */
    void coreAppendChildren(CoreDocumentFragment newChildren) throws CoreModelException;
    
    CoreDocumentTypeDeclaration coreAppendDocumentTypeDeclaration(String rootName, String publicId, String systemId) throws ChildNotAllowedException, DeferredParsingException;
    
    CoreNSUnawareElement coreAppendElement(String tagName) throws ChildNotAllowedException, DeferredParsingException;
    
    CoreNSAwareElement coreAppendElement(String namespaceURI, String localName, String prefix) throws ChildNotAllowedException, DeferredParsingException;
    
    <T extends CoreNSAwareElement> T coreAppendElement(Class<T> extensionInterface, String namespaceURI, String localName, String prefix) throws ChildNotAllowedException, DeferredParsingException;
    
    CoreProcessingInstruction coreAppendProcessingInstruction(String target, String data) throws ChildNotAllowedException, DeferredParsingException;
    
    CoreCharacterData coreAppendCharacterData(String data) throws ChildNotAllowedException, DeferredParsingException;

    CoreComment coreAppendComment(String data) throws ChildNotAllowedException, DeferredParsingException;

    CoreCDATASection coreAppendCDATASection() throws ChildNotAllowedException, DeferredParsingException;

    CoreEntityReference coreAppendEntityReference(String name) throws ChildNotAllowedException, DeferredParsingException;
    
    <T extends CoreChildNode> ChildIterator<T> coreGetChildrenByType(Axis axis, Class<T> type);
    ChildIterator<CoreNSAwareElement> coreGetElementsByName(Axis axis, String namespaceURI, String localName);
    ChildIterator<CoreNSAwareElement> coreGetElementsByNamespace(Axis axis, String namespaceURI);
    ChildIterator<CoreNSAwareElement> coreGetElementsByLocalName(Axis axis, String localName);
    
    <T extends CoreChildNode> T coreGetFirstChildByType(Class<T> type) throws DeferredParsingException;
}
